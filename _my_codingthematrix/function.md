---
layout: mathjax
title: 함수
---

Coding the Matrix 책에서 설명하는 함수를 공식적으로 설명하는 문장은 다음과 같습니다.

<div class="def">
함수는 쌍 \( (a,b) \) 들의 집합이며, 이때 각 쌍의 첫 번째 원소는 모두 다르다.
</div>

여기서 \\( a \\)는 정의역의 원소, \\( b \\)는 정의역의  \\( image \\)입니다.

정의역의 집합을 \\( D \\), 공역의 집합을 \\( F \\)라고 하면
\\( D \\)에서 \\( F \\)로의 함수 \\( f \\)는 다음과 같이 나타냅니다.

$$ f : D \longrightarrow F $$

함수에서 각 함수값에 대한 정의역의 원소는 유일해야 합니다. 예를 들어,

$$ x = 2 $$

는 함수가 아닙니다.

아주 기초적이고 당연한 부분이지만 이 부분을 무심코 넘어가다가 전체 프로시저가 잘못 될 수 있습니다.

<div class="def">
프로시저란 계산 절차에 대한 정확한 기술이며 입력(매개변수)를 받아들여 출력(리턴 값)을 생성한다.
</div>

함수와 프로시저가 헷갈릴 수 있습니다.
그냥 계산 절차의 있고 없고가 아니냐 라는 말을 할 수 있겠지만 **출력값이 유일할 필요가 없습니다.**

$$ 함수 \subsetneq 프로시저 $$

가 되겠네요.

다음 두가지의 계산 문제가 있습니다.

* 함수 \\(f\\)의 정의역에 속하는 원소 \\(a\\)에 대해 \\(f(a)\\)를 구하기.

* 함수 \\(f\\)의 공역의 원소 \\(r\\)에 대해 임의의 역상\\((inverse\ image)\\)을 구하기.

일단 구하는 결과는 존재한다고 가정합시다.

\\(f\\)는 함수이므로 \\(f(a)\\)는 유일합니다.

프로시저를 \\(P(x)\\)라고 하면 첫 번째 계산 문제의 프로시저 \\(P(x)\\)는 함수가 됩니다.

하지만 두 번째 계산 문제는 역상의 결과는 가정에 의해 존재하지만 유일한지는 알 수 없습니다.

전사함수\\( (onto\ function) \\) 일 수도 있으니까요.

<div class="def">
  함수 \( f : D \longrightarrow F \)에서 모든 \(x, y \in  D\)에 대해
  \( f(x) = f(y) \Rightarrow x = y\) 이면 단사함수라 한다.

  모든\( z\in F\)에 대해,\( f(x)=z\)을 만족하는\( x \in D\)가 존재하는 함수 \(f\)를 전사함수라 한다.
</div>

하지만 두 계산 문제 모두 프로시저가 될 수 있습니다.

Coding the Matrix에서 사용하는 프로그래밍 언어 파이썬에서는 프로시저를 **컴프리헨션** 이라는 개념으로 코딩할 수 있습니다.

컴프리헨션은 for-loop 없이 **집합, 리스트, 딕셔너리** 등의 각 원소에 대한 계산을 쉽게 표현할 수 있게 해줍니다. 수학에서 집합을 정의하는 방식과 매우 비슷합니다.

예를 하나 들어보겠습니다.
$$ \lbrace 2x\ |\ x \in \lbrace1, 2, 3\rbrace \rbrace $$

이를 파이썬 컴프리헨션으로 나타내면

```Python
{2*x for x in {1, 2, 3}}
```

집합내의 원소는 순서가 없습니다. 순서는 **리스트** 로 나타내야합니다.

```Python
[2*x for x in {2, 1, 3, 4, 5}]

결과 : [2, 4, 6, 8, 10] 또는 [4, 2, 6, 8, 10]
```

\\({2, 1, 3, 4, 5}\\)는 순서가 없기 때문에 결과는 임의로 배정됩니다.

**투플** 이라는 개념이 있습니다.
리스트와 마찬가지로 순서가 있지만, **원소가 변하지 않습니다.**

수학에서의 순서쌍 개념이라고 할 수 있습니다.

```Python
{0, (1, 2)} | {(3, 4, 5)}

결과 : {(1, 2), 0, (3, 4, 5)}
```

파이썬에서 가장 강력한 기능인 **딕셔너리** 는 키:값 쌍들의 집합입니다.
키:값 한 쌍은 투플입니다. 따라서 키:값 쌍 끼리의 순서는 상관없으며, 키는 변경이 불가능합니다. 다른 언어에서는 할 수 없는 키에 복수 투플을 부여할 수 있습니다.

변경이 불가능한 속성이 주어졌기 때문입니다.
표현식을 사용하여 명시할 수도 있습니다.

```Python
{2+1:'thr'+'ee', 2*2:'fo'+'ur'}
```

프로시저를 다음 한줄과 같이 정의할 수 있습니다.

```Python
def twice(x): return 2*x
```

$$ twice : X \longrightarrow 2X $$ 표기와 매우 흡사한 것을 알 수 있습니다.
