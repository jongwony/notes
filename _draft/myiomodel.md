

`select`, `poll` 함수는 비동기 함수가 아니다?

네트워크나 이벤트를 받았을 때 콜백함수에
`blocking`이 일어나서
그럼 `blocking`은 언제 일어나는 것일까요?

## Connecting Device

모든 I/O는 장치에 작동되며 이 장치들이 연결되어 있어야 합니다.
예를 들어, 장치에는 `저장 장치`, 네트워크 연결이나 블루투스와 같은 `네트워크 장치`, 키보드 마우스 등의 `인터페이스 장치`로 나눌 수 있습니다.
이 장치 간 I/O를 위해서는 실행 중인 `프로세스`를 통해 장치들을 연결하여 I/O를 진행하게 됩니다.

예를 들어 Python을 이용하여 사용자의 입력을 받는 I/O를 한다고 가정하면,
Python으로 프로그래밍 해서 새로운 Python 프로세스를 만듭니다.
Python 프로세스는 `input()` 함수를 통해 사용자의 입력을 받습니다.
이 때 Python 프로세스는 `blocking` 상태가 되고 시스템 콜을 호출해 커널 프로세스가 사용자의 입력을 기다립니다.
사용자로 부터 입력을 받으면 값을 복사하여 Python 프로세스에게 돌려줍니다.

```python
>>> i = input();
HELLO
>>> i
'HELLO'
```

이번에는 Python 프로세스가 `open()` 함수를 호출하여 시스템 콜을 통해 커널 프로세스가 데이터를 읽고 쓸 수 있도록 연결하게 되며 이 동안 Python 프로세스 역시 `blocking` 상태가 됩니다.
일반적으로 커널의 파일의 열기가 끝나게 되면 커널 프로세스는 `파일 디스크립터`를 포함하는 `layer`를 Python 프로세스에게 돌려줍니다.
마찬가지로 `write`, `read` 함수를 통해 커널 프로세스가 데이터를 읽고 쓰는 동안 Python 프로세스는 `blocking` 상태가 됩니다.

네트워크의 소켓 연결을 예로 들면 소켓의 파일 디스크립터를 이용하여 `open` 함수를 수행한 후
`bind`, `listen`, `accept`를 통해 연결하고 TCP의 경우 `recv`, `send`, UDP의 경우 `recvfrom`, `sendfrom`을 통한 I/O가 발생하게 됩니다.

**여기서 공통적으로 I/O는 `open`을 통해 먼저 장치 간 연결을 한다는 것을 알 수 있습니다.** 키보드를 통한 사용자 `input`은 `bus`를 통해 이미 연결되어 있습니다.

`blocking`은 시스템 콜이 일어날 때마다 발생하지만 연결된 장치 간의 I/O 작업에서 데이터 `blocking`은 주로 다음과 같은 `input`에서 일어난다는 것을 알 수 있습니다.

- 커널 프로세스가 사용자의 키보드 입력을 기다리고 있습니다.
- 커널 프로세스가 데이터 수신을 기다리고 있습니다.

일반적으로 `input` 작업에는 다음 두 가지 단계로 나타낼 수 있습니다.

1. 데이터 준비가 완료될 때까지 대기합니다. 예를 들어 `input()` 함수를 통해 데이터가 `\n` 또는 `\r\n`을 받을 때 까지 `blocking`이 일어나게 됩니다. 또한 네트워크에서 데이터가 `recv` 또는 `recvfrom`을 통해 네트워크에 도착하기를 기다리는 것을 포함합니다. 이떄 패킷이 도착하면 커널 내의 버퍼에 복사됩니다.
1. 커널에서 프로세스로 데이터를 복사합니다. 준비된 데이터는 커널의 버퍼에 있으며 다시 프로세스(애플리케이션)의 버퍼로 복사하는 것을 의미합니다.

이제 이 `blocking`을 줄이기 위해 `I/O Model`을 생각해 보기 시작합니다.

## I/O Model

유닉스에서는 일반적으로 5가지의 `I/O Model`이 있습니다.

- Blocking I/O
- Nonblocking I/O
- I/O multiplexing (`select`, `poll` 등)
- Signal driven I/O (`SIGIO`)
- Asynchronous I/O (POSIX `aio_` 함수)

Event driven은 I/O multiplexing의 추상화입니다.

#### Blocking I/O

가장 일반적인 모델입니다. 기본적으로 해당 프로세스 및 모든 소켓이 차단됩니다.

![그림 1. I/O blocking](/image/iomodel/blockingio.png)

위 모델은 일반적인 UDP 환경이나 사용자로부터 키보드 입력을 받는 시나리오를 예로 들 수 있습니다. TCP 환경에서는 소켓의 `low-water mark` 같은 추가 변수가 작용할 수 있으므로 위 시나리오 보다는 조금 더 복잡해 질 수 있겠습니다.

Python의 `input` 함수를 통해 설명했으므로 UDP 환경을 예로 들면 `recvfrom` 함수를 애플리케이션에서 호출하면서 시스템 콜이 일어나고 커널 프로세스에서 데이터 수신이 완료될 때까지 기다리게 됩니다.
UDP에서 데이터 단위인 데이터그램 수신이 완료되면 버퍼를 애플리케이션 프로세스의 버퍼로 복사합니다.

문제는 애플리케이션 프로세스 버퍼에 복사가 완료될 때까지, 또는 그 전에 오류가 발생할 때까지 시스템 콜이 반환되지 않으며 애플리케이션 프로세스는 계속 `blocking`된 상태가 됩니다.
성공적으로 반환이 되어야 애플리케이션이 수신한 데이터를 처리할 수 있게 되는 것입니다.

#### Nonblocking I/O

`nonblocking I/O`는 데이터가 준비 완료될 때까지 `바쁜 대기(busy-waiting)` 즉, `풀링(polling)`을 하게 됩니다. 그러므로 준비 완료된 데이터를 받기 전 까지는 계속 애플리케이션 함수를 호출하는 것을 말합니다. 시나리오는 아래와 같습니다.

![그림 2. I/O nonblocking](/image/iomodel/nonblockingio.png)

그림과 같이 함수를 호출하는 동안 데이터가 아직 준비되지 않았다는 오류를 받습니다. 그림에 오류라고 표현했지만 `false` 값을 반환할 수도 있습니다.

준비된 값을 애플리케이션 프로세스 버퍼에 복사가 완료될 때까지, 또는 그 전에 오류가 발생할 때까지 시스템 콜이 반환되지 않으며 애플리케이션 프로세스가 그 동안 `blocking`된 상태가 되는 것은 동일합니다.

여기서 모델 이름이 `nonblocking`이지만 실제로 커널 프로세스의 `blocking`은 막을 수 없으며 바꿔 말하면 `nonblocking`도 `blocking`이 일어난다고 말할 수 있습니다.

이 모델은 계속 함수를 호출하기 때문에 CPU가 낭비될 수 있지만 한 함수만 쓰는 시스템에 사용 될 수 있습니다. 예를 들어 `Windows API Message Loop`은 `GetMessage` 함수만 쓰므로 `nonblocking I/O`라고 할 수 있겠습니다.

#### I/O multiplexing

`I/O multiplexing`은 데이터가 준비 완료될 때까지 `blocking I/O`처럼 차단되는 것은 동일합니다. 하지만 하나 이상의 파일 디스크립터를 대기하여 다중화 할 수 있다는 것입니다.

![그림 3. I/O multiplexing](/image/iomodel/iomultiplexing.png)

위 시나리오에서는 멀티플렉싱 함수로 `select`를 예로 들었습니다. 읽을 수 있는 UDP 소켓 디스크립터를 리턴 받는 다면 `recvfrom` 함수를 호출하여 커널 프로세스가 데이터그램을 복사할 것입니다.

그렇다면 `blocking I/O`와의 장단점을 다음과 같이 비교 할 수 있습니다.

- I/O multiplexing의 장점: 하나 이상의 디스크립터에서 준비 완료 되었는지 대기할 수 있습니다.
- I/O multiplexing의 단점: 한 번 데이터를 얻기 위해 두번의 시스템 콜을 필요로 합니다. 예를 들어 UDP의 경우 `select`와 `recvfrom` 두 시스템 콜이 필요합니다.

비슷한 방법으로 `blocking I/O`에서 여러 디스크립터를 대기하기 위해 `blocking I/O`에 멀티 스레딩을 사용하는 경우도 있습니다.

#### Signal driven I/O

#### Asynchronous I/O
