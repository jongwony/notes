---
layout: post
title: Python cookbook Chapter 8 한글
tags: ['python', 'docs', 'class', 'object', 'design pattern', '한글']
progress: 99
---

<div id='index-table'>
<h2>8. Classes and Objects</h2>
</div>

- - -

<div class='warn'>
이 문서는 Python Coobook 3rd edition - O'REILLY, David Beazley & Brian K. jones 를 참고한 것이며 개인적인 번역으로 인한 오역이 있을 수 있습니다.<br> <a href="//wikidocs.net/book/1">Python을 완전히 처음 접하는 경우</a>에는 적합하지 않습니다.<br>
</div>

이 장의 주된 포커스는 클래스 정의와 연관된 일반적인 프로그래밍 패턴에 대한 레시피를 제시하는 것입니다. 주제는 일반적인 Python 기능과, 특수한 메서드의 사용, 캡슐화 기술, 상속, 메모리 관리 및 유용한 디자인 패턴을 지원하는 객체 작성을 포함합니다.

## 8.1. Changing the String Representation of Instances

#### Problem

인스턴스를 출력하거나 보면서 생성된 결과를 좀 더 합리적인 것으로 변경하려고 합니다.

#### Solution

인스턴스의 문자열 표현의 변경을 위해서는 `__str__()`와 `__repr__()` 메서드를 정의합니다.

```python
class Pair:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return 'Pair({0.x!r}, {0.y!r})'.format(self)
    def __str__(self):
        return '({0.x!s}, {0.y!s})'.format(self)
```

`__repr__()` 메서드는 인스턴스의 코드 표현을 반환하며 이는 보통 인스턴스를 재생성하기 위해 입력하는 텍스트입니다.
`built-in repr()` 함수는 값을 검사할 때 대화식 인터프리터와 같이 이 텍스트를 반환합니다. `__str__()` 메서드는 인스턴스를 문자열로 변환하며 이는 `str()`와 `print()` 함수에 의해 결과가 생성됩니다.

```python
>>> p = Pair(3, 4)
>>> p
Pair(3, 4)      # __repr__() output
>>> print(p)
(3, 4)          # __str__() output
```

이 방법의 구현은 `formatting`을 사용하는 동안 어떻게 문자열 표현이 다른지도 보여줍니다.
특히, 특별한 `!r` 코드 `formatting`은 `__repr__()`의 결과가 기본적으로 `__str__()` 대신에 사용되어야 함을 가리킵니다.
앞의 클래스에서 이 실험을 시도할 수 있습니다.

```python
>>> p = Pair(3, 4)
>>> print('p is {0!r}'.format(p))
p is Pair(3, 4)
>>> print('p is {0})'.format(p))
p is (3, 4)
```

#### Discussion

`__repr__()`과 `__str__()`을 정의하는 것은 디버깅과 인스턴스 출력을 단순화 할 수 있는 것과 같이 종종 좋은 방법이 됩니다. 예를 들어 단지 인스턴스의 프린팅 또는 로깅에 의해 프로그래머가 좀 더 인스턴스 내용에 대한 유용한 정보를 볼 수 있을 것입니다.

`eval(repr(x)) == x`을 만족하는 텍스트를 생성하는 `__repr__()`의 출력은 표준적인 방법입니다.
이것이 불가능하거나 바라지 않는다면, 대신 `<and>`로 묶인 유용한 텍스트 표현을 만드는 것이 일반적입니다.

```python
>>> f = open('file.dat')
>>> f
"""<_io.TextIOWrapper name='file.dat' mode='r' encoding='UTF-8'>"""
```

`__str__()`가 정의되지 않았다면 `__repr__()`의 출력은 대체로써 사용됩니다.

Solution에서의 `format()` 사용은 약간 재미있어 보일 지 모르겠지만, `{0.x}` 서식 코드는 인수의 `x`속성을 0으로 지정합니다. 그러므로 다음 함수에서 `0`은 실제로 인스턴스 `self`입니다.

```python
def __repr__(self):
    return 'Pair({0.x!r}, {0.y!r})'.format(self)
```

이 구현의 대안으로 `%` 연산자를 다음과 같이 사용할 수도 있습니다.

```python
def __repr__(self):
    return 'Pair(%r, %r)' % (self.x, self.y)
```

## 8.2. Customizing String Formatting

#### Problem

`format()` 함수와 문자열 메서드를 통해 커스터마이징 된 서식 객체를 지원하려고 합니다.

#### Solution

문자열 서식을 커스터마이징하기 위해서는 클래스에 `__format__()` 메서드를 정의합니다.

```python
_formats = {
    'ymd' : '{d.year}-{d.month}-{d.day}',
    'mdy' : '{d.month}/{d.day}/{d.year}',
    'dmy' : '{d.day}/{d.month}/{d.year}'
}

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def __format__(self, code):
        if code == '':
            code = 'ymd'
            rmt = _formats[code]
        return fmt.format(d=self)
```

`Date` 클래스의 인스턴스가 이제 다음과 같이 서식 연산을 지원합니다.

```python
>>> d = Date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d, 'mdy')
'12/21/2012'
>>> 'The date is {:ymd}'.format(d)
'The date is 2012-12-21'
>>> 'The date is {:mdy}.'.format(d)
'The date is 12/21/2012'
```

#### Discussion

`__format__()` 메서드는 Python의 문자열 서식 기능에 `hook`을 제공합니다.
서식 코드를 번역하는 것이 전적으로 클래스 자체에 있다는 점이 중요합니다. 
그러므로 코드가 거의 모든 것이 될 수 있습니다. 예를 들어 다음 `datetime` 모듈을 고려해보면

```python
>>> from datetime import date
>>> d = date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d,'%A, %B, %d, %Y')
'Friday, December 21, 2012'
>>> 'The end is {:%d %b %Y}. Goodbye'.format(d)
'The end is {21 Dec 2012. Goodbye'
```

`built-in` 타입의 서식 지정을 위한 표준 규칙이 있습니다. 형식 지정을 위한 [`string` 모듈 문서](//docs.python.org/3/library/string.html)를 참고하시기 바랍니다.

## 8.3. Making Objects Support the Context-Management Protocol

#### Problem

`context-management`(`with` 문) 프로토콜을 지원하는 객체를 생성하려고 합니다.

#### Solution

`with` 문과 호환되는 객체를 생성하기 위해서 `__enter__()`와 `__exit__()` 메서드를 구현해야 합니다.
예를 들어 네트워크 연결을 제공하는 다음 클래스를 고려합니다.

```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = AF_INET
        self.type = SOCK_STREAM
        self.sock = None

    def __enter__(self):
        if self.sock is not None:
            raise RuntimeError('Already connected')
        self.sock = socket(self.family, self.type)
        self.sock.connect(self.address)
        return self.sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.sock.close()
        self.sock = None
```

이 클래스의 핵심 기능은 네트워크 연결을 나타내지만 처음에는 실제로 아무것도 하지 않습니다(연결을 설정하지 않습니다).
대신에, `with` 문을 사용하여 연결이 설정하고 닫습니다(필수적으로 필요에 따라).

```python
from functools import partial

conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
    # conn.__enter__() executes: connection open
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))
    # conn.__exit__() executes: connection closed
```

#### Discussion

컨텍스트 매니저 작성의 주요 원칙은 `with` 문의 사용으로 정의된 문장의 블록을 둘러 싸는 코드를 작성하는 것입니다. `with` 문이 처음에 도달하면 `__enter__()` 메서드가 트리거됩니다.
`__enter__()`의 반환 값은(있는 경우) `as` 한정자를 가리키는 변수로 저장됩니다.
그 후, `with` 문의 내부가 실행됩니다. 마지막으로 `__exit__()` 메서드가 정리를 위해 트리거됩니다.

이 제어 흐름은 예외가 있는 경우를 포함하여 `with` 문의 내부에서 무엇이 일어나는지 상관 없이 발생합니다.
사실 `__exit__()` 메서드의 세 인수는 예외를 보류하기 위한 예외 `type`, `value`, `traceback`을 포함합니다(있는 경우).
`__exit__()` 메서드가 예외 정보를 사용하거나 아무것도 하지 않고 결과로 `None`을 반환하여 이를 무시하도록 선택할 수 있습니다. 
`__exit__()`가 `true`를 반환한다면 예외는 아무 일 없이 `eith` 블록 바로 다음 문을 계속 실행하는 것처럼 정리됩니다.

한가지 이 방법의 미묘한 점은 `LazyConnection` 클래스가 여러 `with` 문의 중첩을 허용하는지의 여부입니다.
보시다시피 한번에 단일 소켓만 허용되며 소켓이 이미 사용 중일 때 반복된 `with`문이 시도되면 예외를 일으키게 됩니다.
이 제한을 다음과 같은 약간 다른 구현으로 해결할 수 있습니다.

```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = AF_INET
        self.type = SOCK_STREAM
        self.connections = []

    def __enter__(self):
        sock = socket(self.family, self.type)
        sock.connect(self.address)
        self.connections.append(sock)
        return sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.connections.pop().close()

# Example use
from functools import partial

conn = LazyConnection(('www.python.org', 80))
with conn as s1:
    ...
    with conn as s2:
        ...
        # s1 and s2 are independent sockets
```

두 번째 버전은 `LazyConnection` 클래스가 연결을 위한 팩토리의 일종으로 사용됩니다.
내부적으로 리스트가 스택으로 유지되기 위해 사용됩니다. `__enter__()`가 실행될 때마다 새로운 연결이 생성되고 스택에 추가됩니다. `__exit__()` 메서드는 단순히 마지막 연결을 스택에서 `pop`하고 닫습니다. 미묘하지만 위와 같이 한 번의 `with` 문 중첩으로 다중 연결이 생성됩니다.

컨텍스트 매니저는 파일, 네트워크 연결, `lock`과 같은 리소스를 관리할 필요가 있는 프로그램에 가장 일반적으로 사용됩니다.
이런 리소스의 핵심적인 부분은 올바르게 작동하기 위해 명시적으로 닫거나 해제해야 한다는 것입니다. 예를 들어 `lock`을 얻으면 그것을 해제해 주어야 하며, 그렇지 않으면 `deadlock`의 위험이 있습니다. `__enter__()`와 `__exit__()`을 구현과 `with` 문을 사용함으로써 이런 문제를 좀 더 쉽게 피할 수 있습니다. `__exit__()` 메서드의 정리 코드가 무엇이든 상관없이 실행이 보장되기 때문입니다.

컨텍스트 매니저의 대안이 되는 공식은 `contextmanager` 모듈에서 찾을 수 있습니다. [9.22장]()을 참고하시기 바랍니다.
이 장의 `thread-safe` 버전은 [12.6장]()에서 찾을 수 있습니다.

## 8.4. Saving Memory When Creating a Large Number of Instances

#### Problem

프로그램이 인스턴스의 매우 큰 수를 만들어내고(100만 단위) 많은 메모리를 사용합니다.

#### Solution

주로 간단한 데이터 구조로 사용되는 클래스의 경우 `__slots__` 속성을 클래스 정의에 추가함으로써 인스턴스 메모리 사용 영역을 크게 줄일 수 있습니다.

```python
class Date:
    __slots__ = ['year', 'month', 'day']
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
```

`__slots__`를 정의할 때 Python은 인스턴스에 훨씬 더 컴팩트한 내부 표현을 사용합니다.
각 인스턴스가 `dictionary`로 구성되는 대신, 인스턴스가 `tuple` 또는 `list`와 유사한 작은 고정된 사이즈 배열을 생성합니다.
`__slots__` 지정자로 나열된 속성 이름은 이 배열 내의 특정 인덱스에 내부적으로 매핑됩니다.
슬롯 사용의 부작용은 새로운 속성이나 인스턴스를 더 이상 추가할 수 없다는 것입니다.
`__slots__` 지정자에 나열된 속성 이름으로만 제한됩니다.

#### Discussion

슬롯 사용으로 인한 메모리 절약은 저장된 속성의 수와 타입에 따라 다릅니다.
하지만 일반적으로 메모리 사용의 결과는 `tuple`에 저장되는 데이터와 비교됩니다.
설명하자면 단일 `Date` 인스턴스를 슬롯 없이 저장하는 것은 Python 64비트 버전에서 428 바이트의 메모리가 필요합니다. 슬롯이 정의된다면 156 바이트가 감소하게 됩니다.
한번에 큰 수의 날짜를 조작하는 프로그램에서 이는 전체적인 메모리 사용을 크게 줄여줍니다.

비록 슬롯이 일반적으로 사용되는 기능처럼 보이지만 대부분의 코드에서는 슬롯을 사용하지 않는게 좋습니다. Python의 많은 부분에서 일반적으로 `dictionary` 기반의 구현에 의존합니다.
추가로 슬롯 정의 클래스는 다중 상속 같은 기능을 제공하지 않습니다.
대부분 자주 사용되는 데이터 구조로 쓰는 클래스에서만 슬롯을 사용하는 것이 좋습니다(예. 프로그램이 특정 클래스 인스턴스를 백만 단위로 생성할 경우).

`__slots__`에 대한 일반적인 오해는 사용자가 인스턴스에 새로운 속성을 추가할 수 없도록하는 캡슐화 도구라는 것입니다. 비록 이런 `side effect`로 슬롯을 사용하더라도 이는 절대 원래 목적이 아닙니다. 대신 `__slots__`는 항상 성능 도구로 사용된 경향이 있습니다.

## 8.5. Encapsulating Names in a Class

#### Problem

클래스 인스턴스의 *Private* 데이터를 캡슐화하려 하지만 Python의 액세스 컨트롤 부족이 우려됩니다.

#### Solution

데이터 캡슐화를 위한 언어의 기능에 의존하는 것 보다는 Python 프로그래머들은 데이터와 메서드의 의도된 사용법에 관한 특정 명명 규칙을 준수하길 기대합니다.
첫 번째 규칙은 모든 이름이 단일 밑줄(`_`)로 시작하여 항상 내부적인 구현이라고 가정한다는 것입니다.

```python
class A:
    def __init__(self):
        self._internal = 0      # An internal attribute
        self.public = 1         # A public attribute

    def public_method(self):
        '''
        A public method
        '''
        ...

    def _internal_method(self):
        ...
```

Python은 실제로 내부 이름에 액세스하는 것을 막지는 않습니다. 하지만 그렇게 하면 무례하다는 인식이며, 코드가 깨지기도 쉽습니다.
밑줄 사용은 모듈 이름과 모듈 레벨 함수에도 사용된다는 점에 유의해야 합니다.
예를 들어, 밑줄로 시작하는 모듈 이름을 본적이 있다면(`_socket`) 내부적인 구현을 나타냅니다.
마찬가지로 `sys._getframe()`과 같은 모듈 레벨 함수 역시 아주 조심해서 사용하여야 합니다.

또한 밑줄 두개를 사용해서 시작하는(`__`) 이름의 클래스 내부 정의도 볼 수 있습니다.

```python
class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        ...

    def public_method(self):
        ...
        self.__private_method()
        ...
```

밑줄 두개를 사용하면 다른 이름으로 망가지게 됩니다. 특히 이전의 클래스에서 *private* 속성은 `_B__private`와 `_B__private_method`로 각각 이름이 바뀌게 됩니다. 이 시점에서 이름을 망가지게 하는 것이 어떤 목적을 위한 것인지 궁금할 수도 있습니다. 답은 상속이며 속성이 상속으로 인한 *override*를 할 수 없습니다.

```python
class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1      # Does not override B.__private

    # Does not overrice B.__private_method()
    def __private_method(self):
        ...
```

여기서 *private* 이름의 `__private`와 `__private_method`는 `B`클래스 기반의 이름과는 다른 `_C__private`와 `_C__private_method`로 바뀐 이름을 얻습니다.

#### Discussion

*private* 속성의 두가지 다른 규칙이 있다는 사실은(단일 밑줄 vs 두개의 밑줄) 어떤 스타일을 사용해야 하는지의 명확한 질문을 이끌어냅니다. 대부분의 코드에서 단일 밑줄로 시작하여 *nonpublic*한 이름을 만들어 낼 것입니다. 하지만 때론 코드가 서브 클래스를 포함할 것이고, 서브클래스로부터 숨겨야하는 내부적인 속성이 있습니다. 이때는 두개의 밑줄을 사용합니다.

예약어의 이름과 충돌하는 변수를 원할 때도 있을 것입니다. 이때는 단일 밑줄을 끝에 사용하는 것이 좋습니다.

```python
lambda_ = 2.0       # Trailing _ to avoid clash with lambda keyword
```

앞서 언급한 밑줄을 사용하지 않는 이유는 의도된 사용법에 대한 혼란을 피하기 위해서입니다(즉 *private* 변수를 가리키는 것 보다는 이름 충돌을 피하기 위한 방법으로 해석될 수 있습니다).
마지막에 단일 밑줄을 사용하여 이 문제를 해결할 수 있습니다.

## 8.6. Creating Managed Attributes

#### Problem

인스턴스 속성을 얻거나 설정하는 데 추가적인 처리(타입 체크 또는 유효성 검사)를 원합니다.

#### Solution

속성에 액세스하기위한 커스터마이즈의 간단한 방법은 *property*를 정의하는 것입니다.
예를 들어 이 코드는 속성의 타입 체크를 위해 간단하게 추가한 *property*를 정의합니다.

```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Cannot delete attribute")
```

이전 코드에서 세가지 연관된 메소드가 있으며 모두 같은 이름이어야 합니다.
첫 번째 메서드는 `getter` 함수이며 `first_name`을 *property*로 설정합니다.
다른 두 메서드는 `first_name` *property*에 부가적으로 `setter`와 `deleter`가 첨부됩니다.
이는 `@first_name.setter`와 `@first_name.deleter` 데코레이터가 `first_name`이 이미 *property*로 `@property`를 이미 설정하지 않은 이상 정의되지 않는다는 점이 중요합니다.

*property*의 중요한 특징은 평범한 속성으로 보이지만 액세스가 자동으로 `getter`, `setter`와 `deleter` 메서드를 트리거한다는 것입니다.

```python
>>> a = Person('Guido')
>>> a.first_name    # Calls the getter
'Guido'
>>> a.first_name = 42
TypeError: Expected a string
>>> del a.first_name
AttributeError: Cannot delete attribute
```

*property*를 구현할 때 기본 데이터가(있다면) 여전히 어딘가에 저장이 되어야 합니다.
그러므로 메서드의 `get`과 `set`에서 실제 데이터가 있는 `_first_name` 속성을 직접 조작할 수 있습니다.
추가적으로 왜 `__init__()` 메서드에 `self._first_name` 대신 `self.first_name`이 설정되었는지 궁금할 것입니다.
이 예제에서 *property*의 전체적인 포인트는 속성을 설정할 때 타입 체크를 적용하는 것입니다.
그러므로 초기화하는 동안 이런 체킹 작업을 수행할 수도 있습니다.
`self.first_name`으로 설정함으로써 `set` 작업은 `setter` 메서드를 사용하는 것입니다(`self._first_name`에 액세스하여 우회하는 것과는 반대).

*property*들은 또한 이미 존재하는 `get`과 `set` 메서드로 정의될 수도 있습니다.

```python
class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError("Cannot delete attribute")

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)
```

#### Discussion

*property* 속성은 실제로 번들로 묶인 메서드 모음입니다. *property*를 가진 클래스를 검사한다면 *property* 자체 속성인 `fget`, `fset`, `fdel`라는 `raw method`를 찾아볼 수 있습니다.

```python
>>> Person.first_name.fget
<function Person.first_name at 0x1006a60e0>
>>> Person.first_name.fset
<function Person.first_name at 0x1006a6170>
>>> Person.first_name.fdel
<function Person.first_name at 0x1006a62e0>
```

일반적으로 `fget` 또는 `fset`을 직접 호출할 수는 없지만 *property*에 액세스 될 때 자동적으로 트리거됩니다.

*property*들은 속성 액세스에 대한 **추가적인 처리를 실제로 수행해야 하는 경우에만** 사용되어야 합니다.
때론 Java와 같은 언어를 사용하는 프로그래머들이 모든 액세스는 `getter`와 `setter`로 처리되어야 한다고 생각하는 경우가 있어 코드를 다음과 같이 작성합니다.

```python
class Person:
    def __init__(self, first_name):
        self.first_name = name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
```

실제로 이와 같이 어떤것도 추가된 것이 없는 *property*를 작성하지 마시길 바랍니다.
첫째로 다른 사람에게 코드를 장황하고 혼란스럽게 만들며 둘째로 프로그램이 훨씬 느려지게 됩니다.
마지막으로 실제로 디자인적인 이점이 없습니다. 특히 나중에 일반 속성을 핸들링할 때 추가적인 처리를 한다고 결정하면 기존 코드를 변경하지 않고 *property*로 승격시킬 수 있습니다.
이는 속성에 액세스한 코드의 구문이 변경되지 않고 남기 때문입니다.

*property*들은 계산된 속성을 정의하는 방법으로도 사용될 수 있습니다. 이런 속성들은 실제로 저장되지는 않지만 필요에 따라 계산됩니다.

```python
import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
```

여기서 *property*를 사용하면 `radius`, `area`, `perimeter`가 간단한 속성과 메서드 호출이 섞인 것이 아니라 단순한 속성으로만 액세스된다는 점에서 매우 균일한 인스턴스 인터페이스가 됩니다.

```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area      # Notice lack of ()
50.26548245743669
>>> c.perimeter # Notice lack of ()
25.132741228718345
```

*property*를 사용하면 우아한 프로그래밍 인터페이스가 제공되지만, 실제로 `getter` 및 `setter` 함수를 직접 사용할 수도 있습니다.

```python
>>> p = Person('Guido')
>>> p.get_first_name()
'Guido'
>>> p.set_first_name('Larry')
```

이는 종종 Python 코드가 시스템 또는 프로그램의 더 큰 인프라로 통합되는 상황에 발생합니다.
예를 들어 Python 클래스가 원격 프로시저 호출 또는 분산 객체를 기반으로 하는 대규모 분산처리 시스템에 플러그인 될 것입니다. 이러한 설정에서는 암묵적으로 호출하는 속성이 아닌 명시적으로 `get`/`set` 메서드(일반 메서드 호출)로 작업하는 것이 훨씬 쉽습니다.

마지막으로 반복적으로 *property*가 정의가 많은 다음과 같은 Python 코드를 작성하지 마십시오.

```python
class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Repeated property code, but for a different name (bad!)
    @property
    def last_name(self):
        return self._last_name

    @last_name.setter
    def last_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._last_name = value
```

코드 반복은 거품이며, 에러가 발생하기 쉽고, 잘못된 코드로 이어집니다. 결과적으로 *descriptor*나 *closure*를 사용하여 동일한 것을 달성하는 것이 더 좋은 방법입니다.
[8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)과 [9.21장]()을 참고하시기 바랍니다.

## 8.7. Calling a Method on a Parent Class

#### Problem

서브클래스에서 *override*된 메서드 대신 부모 클래스에서 메서드를 호출하길 원합니다.

#### Solution

부모(또는 `superclass`)에서 메서드를 호출하려면 `super()` 함수를 사용합니다.

```python
class A:
    def spam(self):
        print('A.spam')

class B(A):
    def spam(self):
        print('B.spam')
        super().spam()      # Call a parent spam()
```

`super()`의 매우 일반적인 사용은`__init__()` 메서드를 처리하여 부모가 제대로 초기화 되었는지 확인하는 것입니다.

```python
class A:
    def __init__(self):
        self.x = 0

class B(A):
    def __init__(self):
        super().__init__()
        self.y = 1
```

또 다른 `super()`의 일반적인 사용은 코드에서 Python의 특수한 메서드를 *override*하는 것입니다.

```python
class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)    # Call original __setattr__
        else:
            setattr(self._obj, name, value)
```

이 코드에서 `__setattr__()`의 구현은 이름 체크를 포함합니다. 만일 이름이 밑줄(`_`)로 시작한다면 `super()`를 사용하여 `__setattr__()`의 원래 구현된 것을 호출합니다.
그렇지 않으면 내부적으로 보유한 객체 `self._obj`에 위임합니다.
약간은 흥미로워 보이지만, `super()`는 명시적으로 기본 클래스가 나열되지 않은 경우에도 동작합니다.

#### Discussion

`super()` 함수의 올바른 사용은 실제로 Python의 가장 이해하기 힘든 점 중 하나입니다.
때로는 다음과 같이 부모의 메서드를 직접 호출하는 코드를 보게 되기도 합니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')
```

비록 대부분의 코드에서 동작하지만, 다중 상속을 포함하는 고급 코드에서 이상한 문제가 발생할 수 있습니다. 예를 들어 다음과 같은 코드를 보시기 바랍니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')

class B(Base):
    def __init__(self):
        Base.__init__(self)
        print('B.__init__')

class C(A, B):
    def __init__(self):
        A.__init__(self)
        B.__init__(self)
        print('C.__init__')
```

이 코드를 실행한다면 `Base.__init__()` 메서드가 아래와 같이 두번 호출되는 것을 볼 수 있을 것입니다.

```python
>>> c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
```

`Base.__init__()` 이중 호출이 해가 되진 않지만 그렇지 않을 수도 있습니다.
만일 다른 방법으로는 `super()`를 사용하도록 코드를 바꾸면 모든 코드가 작동됩니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A, B):
    def __init__(self):
        super().__init__()      # Only one call to super() here
        print('C.__init__')
```

이 새로운 버전을 사용할 때 `__init__()` 메서드가 한번만 호출 된다는 것을 알 수 있습니다.

```python
>>> c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
```

이 동작을 이해하려면 잠시 돌아와서 Python이 상속을 구현하는 방법에 대해 설명해야 합니다.
정의한 모든 클래스에 대해 Python은 *MRO(method resolution order)* 리스트로 알려진 것을 계산합니다.
*MRO* 리스트는 단순히 모든 *base* 클래스들의 *linear ordering*입니다.

```python
>>> C.__mro__
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class '__main__.Base'>, <class 'object'>)
```

상속을 구현하기 위해 Python은 가장 왼쪽 클래스로 시작하여 첫번째 속성이 매치될 때까지 *MRO* 리스트의 클래스를 통해 왼쪽에서 오른쪽으로 동작합니다.

*MRO* 목록 자체의 실제 결정은 **C3 Linearization**라고 알려진 기술을 사용하여 수행됩니다.
너무 수학으로 깊이 들어가지 않고 설명하자면 실제로 3개의 제약 조건이 있는 부모 클래스로 부터의 *MRO merge sort*입니다.

- 자식 클래스는 부모 클래스 이전에 체크한다.  
- 여러 부모는 나열된 순서대로 체크한다.  
- 다음 클래스에 대해 두가지 유효한 선택 사항이 있는 경우 첫 번째 부모에서 하나를 선택한다.

솔직히 꼭 알아야 할 것은 정의하고자 하는 거의 모든 클래스의 계층 구조에서 *MRO* 리스트에서 클래스의 순서가 *의미가 있다*는 것입니다.

`super()` 함수를 사용할 때는 Python이 *MRO*의 다음 클래스부터 시작하여 검색을 계속 합니다.
매번 재정의된 메서드가 연속적으로 `super()`를 사용하고 한번만 호출하는 한, 컨트롤은 완전히 전체적인 *MRO* 리스트를 통해 작동하고 각 메서드가 한번만 호출될 것입니다. 이는 두번째 예제에서 `Base.__init__()`가 두번 호출되지 않은 이유입니다.

`super()`의 놀라운 점은 바로 *MRO*의 다음 직접적인 클래스의 부모로 가지 않고 직접적인 부모가 아닌 클래스에서도 사용할 수 있다는 것입니다.

```python
class A:
    def spam(self):
        print('A.spam')
        super().spam()
```

이 클래스 사용을 시도하면 완전히 깨진 것을 알 수 있습니다.

```python
>>> a = A()
>>> a.spam()
A.spam
AttributeError: 'super' object has no attribute 'spam'
```

다중 상속에서 클래스를 사용하기 시작할 때 어떻게 되는지 보시기 바랍니다.

```python
class B:
    def spam(self):
    print('B.spam')

class C(A, B):
    pass
```

```python
>>> c = C()
>>> c.spam()
A.spam
B.spam
```

여기서 `A` 클래스의 `super().spam()` 사용을 보시면 사실 `A` 클래스와 전혀 관련이 없는 `B` 클래스의 `spam()` 메서드가 호출됩니다! 이는 `C` 클래스의 *MRO*가 모든 것을 설명해 줍니다.

```python
>>> C.__mro__
"<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>"
```

이런 식으로 `super()`를 사용하는 것은 `mixin` 클래스를 정의할 때 가장 일반적입니다.
[8.13장](#813-implementing-a-data-model-or-type-system)과 [8.18장](#818-extending-classes-with-mixins)을 참고하시기 바랍니다.

하지만 `super()`가 예상 밖의 메서드를 호출하기 때문에, 따라야 하는 몇가지 일반적인 규칙이 있습니다.
첫번째로, 상속에서 같은 이름을 가진 모든 메소드가 호환되는 호출 서명을 가지고 있는지 확인합니다(즉, 인수의 수나 이름이 같은지). 이러면 직접적인 부모가 아닌 클래스에서 메서드를 호출하려 할 때 `super()`를 거치지 않습니다.
두번째로, 일반적으로 최상위 클래스가 메서드 구현을 제공하여 *MRO*에서 발생하는 조회 체인이 실제 메서드 정렬에 따라 종료되도록 하는 것이 좋습니다.

`super()` 사용은 때론 Python 커뮤니티의 논쟁거리가 됩니다. 그러나 같은 조건에서는 모던 코드에서는 사용해야 할 것입니다. Raymond Hattinger는 블로그 포스트 [Python's `super()` considered Super!](//rhettinger.wordpress.com/2011/05/26/super-considered-super/)에 더 많은 예제와 `super()`가 놀라운 이유가 작성되어 있습니다.

## 8.8. Extending a Property in a Subclass

#### Problem

서브 클래스 내에서 부모 클래스에서 정의된 *property*의 기능을 확장하려고 합니다.

#### Solution

*property*를 정의하는 다음 코드를 살펴보겠습니다.

```python
class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise TypeError("Can't delete attribute")
```

다음은 `Person`의 상속 클래스이며 `name` *property*의 새 기능 확장의 예제입니다.

```python
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
```

다음은 새로운 클래스의 사용 예제입니다.

```python
>>> s = SubPerson('Guido')
Setting the name to Guido
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
Setting name to Larry
>>> s.name = 42
TypeError: Expected a string
```

*property*의 메서드 중 하나만 확장하려는 경우 다음과 같은 코드를 사용합니다.

```python
class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Gettinig name')
        return super().name
```

또는 반대로 `setter`만 확장하려는 경우엔 다음 코드를 사용합니다.

```python
class SubPerson(Person):
    @Person.name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)
```

#### Discussion

서브클래스에서 *property*의 확장은 단일 메서드와는 달리 *property*가 `getter`, `setter`, `deleter` 메서드의 컬렉션으로 정의된다는 사실과 관련된 여러가지 매우 미묘한 문제를 일으킵니다. 그러므로 *property*를 확장할 때 모든 메서드를 재정의할 것인지 그 중 한가지 메서드만 재정의할 것인지 알 필요가 있습니다.

첫 번째 예제에서 모든 *property* 메서드가 재정의되었습니다. 각 메서드 내에서 `super()` 가 이전 구현을 호출하는데 사용됩니다. `setter` 함수의 `super(SubPerson, SubPerson).name.__set__(self, value)` 사용에서 실수는 없습니다.
`setter`의 이전 구현을 위임하기 위해 컨트롤을 이전에 `name` *property*로 정의된 `__set__()` 메서드를 통해 전달해야 합니다.
하지만 이 메서드를 얻는 방법은 인스턴스 변수 대신 클래스 변수로 액세스하는 것 뿐입니다. 이는 `super(SubPerson, SubPerson)` 작업에서 발생합니다.

하나의 메서드만 재정의할 경우 `@property` 단독 사용으로는 충분하지 않습니다. 예를 들어 다음과 같은 코드는 동작하지 않습니다.

```python
class SubPerson(Person):
    @property   # Doesn't work
    def name(self):
        print('Getting name')
        return super().name
```

결과 코드를 시도하면 `setter` 함수가 완전히 사라진 것을 알 수 있습니다.

```python
>>> s = SubPerson('Guido')
AttributeError: cannot set attribute
```

대신, 다음 코드로 바꾸어야 합니다.

```python
class SubPerson(Person):
    @Person.getter
    def name(self):
        print('Getting name')
        return super().name
```

이렇게 하면 모든 이전에 정의된 *property* 메서드들이 복사되고, `getter` 함수가 치환됩니다.
이제 예상대로 작동합니다.

```python
>>> s = SubPerson('Guido')
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
>>> s.name
Getting name
'Larry'
>>> s.name = 42
TypeError: Expected a string
```

이 Solution에서는 하드코딩된 클래스 이름 `Person`을 보다 일반적인 것으로 대체할 수 있는 방법이 없습니다.
어떤 Base 클래스가 *property*를 정의했는지 모르는 경우에는 모든 *property* 메서드가 재정의되고 `super()`가 이전 구현으로 컨트롤을 전달하는 데 사용되는 방법을 사용해야 합니다.

이 장에서 보인 첫 번째 기술은 [8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)에 설명된 *descriptor*로 사용될 수도 있다는 것에 주목할 가치가 있습니다. 예를 들면

```python
# A descriptor
class String:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        instance.__dict__[self.name] = value

# A class with a descriptor
class Person:
    name = String('name')
    def __init__(self, name):
        self.name = name

# Extending a descriptor with a property
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
```

마지막으로, 이 글을 읽을 때쯤 `setter`와 `deleter` 메서드의 서브클래싱이 어느정도 단순화 될 수 있다는 점에 주목할만한 가치가 있습니다.
위 방법은 여전히 잘 동작하지만 [Python's issues page](//bugs.python.org/issue14965)에서의 버그 리포트가 향후 Python 버전에서 보다 명확한 방법으로 해결 될 수 있습니다.

## 8.9. Creating a New Kind of Class or Instance Attribute

#### Problem

타입 체킹과 같은 몇가지 추가 기능과 함께 새로운 종류의 인스턴스 속성 유형을 생성하려고 합니다.

#### Solution

완전히 새로운 종류의 인스턴스 속성을 생성하려면 *descriptor* 클래스의 형태로 그 기능을 정의합니다. 다음은 예제입니다.

```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError('Expected an int')
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]
```

*descriptor*는 특별한 `__get__()`, `__set__()`, `__delete__()` 메서드 형태로 세가지 핵심 속성에 액세스하는 작업(`get`, `set`, `delete`)을 구현하는 클래스입니다.
이 메서드는 인스턴스를 입력으로 받아 동작합니다. 인스턴스의 기본 `dictionary`가 다음에 적절하게 조작됩니다.

*descriptor*를 사용하려면 *descriptor*의 인스턴스를 클래스 변수로써 클래스 정의에 배치합니다.

```python
class Point:
    x = Integer('x')
    y = Integer('y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

이렇게 할 때 모든 *descriptor* 속성에 액세스(`x` 또는 `y`)가 `__get__()`, `__set__()`, `__delete__()` 메서드에 의해 캡쳐됩니다.

```python
>>> p = Point(2, 3)
>>> p.x         # Calls Point.x.__get__(p, Point)
2
>>> p.y = 5     # Calls Point.y.__set__(p, 5)
>>> p.x = 2.3   # Calls Point.x.__set__(p, 2.3)
TypeError: Expected an int
```

입력으로 *descriptor*의 각 메서드가 조작되는 인스턴스를 받습니다. 요청된 작업을 수행하기 위해 기본 인스턴스 `dictionary`(`__dict__` 속성)이 적절하게 조작됩니다. *descriptor*의 `self.name` 속성은 실제 데이터를 인스턴스 `dictionary`에 저장하는 데 사용되는 `dictionary` 키를 보유합니다.

#### Discussion

디스크립터는 `@classmethod`, `@staticmethod`, `@property` 및 `__slots__` 명세를 포함하여 대부분의 Python 클래스 기능에 대한 기본 기술(magic)을 제공합니다.

*descriptor*를 정의함으로써 코어 인스턴스 작업(`get`, `set`, `delete`)을 매우 낮은 레벨에서 캡처할 수 있고 완전히 커스터마이즈 할 수 있습니다. 이로써 큰 힘을 주며 고급 라이브러리와 프레임워크의 작성자가 사용하는 가장 중요한 도구 중 하나입니다.

*descriptor*의 한가지 혼동되는 점은 각 인스턴스별 기반이 아니라 클래스 레벨에서만 정의될 수 있다는 것입니다. 따라서 다음과 같은 코드는 동작하지 않습니다.

```python
# Does NOT work
class Point:
    def __init__(self, x, y):
        self.x = Integer('x')   # No! Must be a class variable
        self.y = Integer('y')

        self.x = x
        self.y = y
```

또한, `__get__()` 메서드의 구현이 보기보다 까다롭습니다.

```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
    ...
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
    ...
```

`__get__()`이 다소 복잡해보이는 이유는 인스턴스 변수와 클래스변수간의 구별을 설명하기 위해서입니다.
*descriptor*가 클래스변수로 액세스되면 `instance` 인수가 `None`으로 설정됩니다.
이 경우 단순히 *descriptor* 인스턴스 자체를 반환하는 것이(비록 어떤 종류의 커스텀 처리도 가능하지만) 표준입니다.

```python
>>> P = Point(2, 3)
>>> p.x         # Calls Point.x.__get__(p, Point)
2
>>> Point.x     # Calls Point.x.__get__(None, Point)
<__main__.Integer object at 0x100671890>
```

*descriptor*는 때론 *decorator*나 *metaclass*들을 포함하는 더 큰 프레임워크의 한 구성요소일 뿐입니다. 따라서 이들의 사용은 알게 모르게 숨어있을 수 있습니다.
예를 들어 다음은 클래스와 관련된 보다 클래스 *decorator*를 포함하는 고급 *descriptor* 기반의 코드입니다.

```python
# Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError('Expected ' + str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance__dict__[self.name]

# class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

마지막으로 특정 클래스의 단일 속성에 대한 액세스를 커스터마이즈하기만 하려면 *descriptor*를 작성하지 않아야합니다. 이는 [8.6장](#86-creating-managed-attributes)에서 설명한 대로 *property*를 사용하는 것이 더 쉽습니다.
*descriptor*는 코드 재사용이 많은 상황에서 더 유용합니다(즉, 수백가지 코드에서 *descriptor*가 제공하는 기능을 사용하거나 라이브러리 기능으로 제공할 경우를 원하는 경우)

## 8.10. Using Lazily Computed Properties

#### Problem

읽기 전용 속성을 액세스시에만 계산되는 *property*로 정의하려고 합니다.
하지만 한번 액세스되면 변수가 캐시되어 각 액세스에서 다시 계산하진 않으려고 합니다.

#### Solution

*lazy* 속성을 정의하는 효율적인 방법은 다음과 같이 *descriptor* 클래스를 사용하는 것입니다.

```python
class lazyproperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value
```

이 코드를 활용하려면 다음과 같은 클래스에서 사용할 수 있습니다.

```python
import math

class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    @lazyproperty
    def area(self):
        print('Computing area')
        return math.pi * self.radius ** 2

    @lazyproperty
    def perimeter(self):
        print('Computing perimeter')
        return 2 * math.pi * self.radius
```

다음 대화 세션은 동작 방법을 설명합니다.

```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.perimeter
Computing perimeter
25.132741228718345
>>> c.perimeter
25.132741228718345
```

"Computing area"와 "Computing perimeter" 메시지가 한번만 나타난다는 것을 주의깊게 관찰하시기 바랍니다.

#### Discussion

많은 경우 *lazy*하게 계산된 속성을 갖는 전체적인 포인트는 성능의 향상입니다.
예를 들어 실제로 어딘가 필요하지 않은 이상 변수 계산을 피합니다. 위의 Solution은 단지 이 작업만 수행하지만 매우 효율적인 방법으로 *descriptor*의 미묘한 기능을 활용하게 됩니다.

다른 장에도 소개되었듯이([8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)), 클래스 정의에 *descriptor*가 배치될 때 `__get__()`, `__set__()`, `__delete__()` 메서드가 속성 액세스시에 트리거됩니다.
하지만 *descriptor*가 `__get__()` 메서드만 정의할 경우 평소보다 바인딩이 훨씬 약합니다.
특히 `__get__()` 메서드가 액세스되는 속성이 기본 인스턴스 `dictionary`에 없는 경우에만 시작됩니다.

이 `lazyproperty` 클래스는 `__get__()` 메서드가 *property* 자체와 동일한 이름을 사용하여 인스턴스에 계산된 값을 저장하도록 함으로써 활용됩니다. 이렇게 함으로써 값은 인스턴스 `dictionary`에 저장되고 *property*의 추가적인 계산이 비활성화됩니다.
예제를 좀 더 자세히 들여다봄으로써 이를 관찰할 수 있습니다.

```python
>>> c = Circle(4.0)
>>> # Get instance variables
>>> vars(c)
{'radius': 4.0}
>>> # Compute area and observe variables afterward
>>> c.area
Computing area
50.26548245743669
>>> vars(c)
{'area': 50.26548245743669, 'radius': 4.0}
>>> # Notice access doesn't invoke property anymore
>>> c.area
50.26548245743669
>>> # Delete the variable and see property trigger again
>>> del c.area
>>> vars(c)
{'radius': 4.0}
>>> c.area
Computing area
50.26548245743669
```

이 장의 한가지 단점은 계산된 값이 생성된 후에 변경 가능하다는 것입니다. 예를 들면

```python
>>> c.area
Computing area
50.26548245743669
>>> c.area = 25
>>> c.area
25
```

이를 고려한다면 다음과 같이 약간 덜 효율적인 구현을 사용할 수 있습니다.

```python
def lazyproperty(func):
    name = '_lazy_' + func.__name__
    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy
```

이 버전을 사용한다면 `set` 연산이 허용되지 않는다는 것을 알 수 있습니다.

```python
>>> c = Circle(4.0)
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.area = 25
AttributeError: cannot set attribute
```

그러나 단점은 모든 `get` 연산이  *property*의 `getter` 함수를 통해 라우트되어야 한다는 점입니다.
이는 원래의 Solution에서와 마찬가지로 단순히 인스턴스 `dictionary`의 값을 찾는 것 보다는 효율적이지 않습니다.

*property*와 속성 변경의 추가 사항은 [8.6장](#86-creating-managed-attributes), *descriptor*는 [8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)을 참고하시기 바랍니다.

## 8.11. Simplifying the Initialization of Data Structures

#### Problem

데이터 구조로 쓰이는 많은 클래스를 작성하고 있지만, 매우 반복적이고 상용(boilerplate) `__init__()` 함수를 작성하는 것이 지겹습니다.

#### Solution

종종 공통 기본 클래스에 정의된 단일 `__init__()` 함수로 데이터 구조 초기화를 일반화 할 수 있습니다.

```python
class Structure:
    # Class variable that specifies expected fields
    _fields = []
    def __init__(self, *args):
        if len(args) != len(self._fields):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        # Set the arguments
        for name, value in zip(self._fields, args):
            setattr(self, name, value)

# Example class definitions
if __name__ == '__main__':
    class Stock(Structure):
        _fields = ['name', 'shares', 'price']

    class Point(Structure):
        _fields = ['x', 'y']

    class Circle(Structure):
        _fields = ['radius']
        def area(self):
            return math.pi * self.radius ** 2
```

결과 클래스를 사용하려면 쉽게 구성할 수 있음을 알 수 있습니다.

```python
>>> s = Stock('ACME', 50, 91.1)
>>> p = Point(2, 3)
>>> c = Circle(4, 5)
>>> s2 = Stock('ACME', 50)
TypeError: Expected 3 arguments
```

키워드 인수를 지원하기로 결정한다면 몇가지 디자인 옵션이 있습니다.
한 가지 선택은 키워드 인수를 지정된 `_fields` 이름의 속성에만 대응시키도록 매핑하는 것입니다.

```python
class Structure:
    _fields = []
    def __init__(self, *args, **kwargs):
        if len(args) > len(self._fields):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        # Set all of the positional arguments
        for name, value in zip(self._fields, args):
            setattr(self, name, value)

        # Set the remaining keyword arguments
        for name in self._fields[len(args):]:
            setattr(self, name, kwargs.pop(name))

        # Check for any remaining unknown arguments
        if kwargs:
            raise TypeError('Invalid arguments(s): {}'.format(','.join(kwargs)))
        
# Example use
if __name__ == '__main__':
    class Stock(Structure):
        _fields = ['name', 'shares', 'price']

    s1 = Stock('ACME', 50, 91.1)
    s2 = Stock('ACME', 50, price=91.1)
    s3 = Stock('ACME', shares=50, price=91.1)
```

또 다른 가능한 선택은 `_fields`에서 지정되지 않은 구조에 추가적인 속성을 추가하는 수단으로 키워드 인수를 사용하는 것입니다.

```python
class Structure:
    # Class variable that specifies expected fields
    _fields = []
    def __init__(self, *args, **kwargs):
        if len(args) != len(self._fields):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        # Set the arguments
        for name, value in zip(self._fields, args):
            set attr(self, name, value)

        # Set the additional arguments (if any)
        extra_args = kwargs.keys() - self._fields
        for name in extra_args:
            setattr(self, name, kwargs.pop(name))
        if kwargs:
            raise TypeError('Duplicate values for {}'.format(','.join(kwargs)))

# Example use
if __name__ = '__main__':
    class Stock(Structure):
        _fields = ['name', 'shares', 'price']

    s1 = Stock('ACME', 50, 91.1)
    s2 = Stock('ACME', 50, 91.1, date='8/2/2012')
```

#### Discussion

범용으로 `__init__()` 메서드를 정의하는 기술은 많은 수의 작은 데이터 구조를 기반으로 작성된 프로그램을 작성할 경우 매우 유용할 수 있습니다.
이는 다음과 같이 수동으로 `__init__()` 메서드를 작성하는 것보다 훨씬 코드가 작아집니다.

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2
```

한가지 구현의 미묘한 점은 `setattr()` 함수를 사용하여 값을 설정하는데 사용되는 메커니즘과 관련이 있습니다. 그렇게 하는 대신 인스턴스 `dictionary`에 직접 액세스하는 경향도 있습니다.

```python
class Structure:
    # Class variable that specifies expected fields
    _fields = []
    def __init__(self, *args):
        if len(args) != len(self._fields):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        # Set the arguments (alternate)
        self.__dict__.update(zip(self._fields, args))
```

이것도 동작하지만 서브클래스의 구현에 대한 가정을 하는 것에 대해 안전하지 않은 경우가 있습니다.
만일 서브클래스가 `__slots__`를 사용하거나 특정 속성을 *property*(또는 *descriptor*)로 `wrap`하기로 결정한 경우 직접적으로 인스턴스 `dictionary`에 액세스할 수 없게 됩니다.
이 Solution은 가능한 한 범용적으로 작성되었으며 서브클래스에 대한 어떠한 가정도 하지 않습니다.

이 기술의 잠재적인 단점은 문서와 IDE의 help 기능에 영향을 줄 수 있다는 것입니다.
사용자가 특정 클래스에 help를 요청하면 필요한 인수가 일반적인 방법으로 설명되지 않습니다.

```
>>> help(Stock)
Help on Class Stock in module __main__:

class Stock(Structure)
...
 |  Methods inherited from Structure:
 |
 |  __init__(self, *args, **kwargs)
 |
...
```

이러한 문제의 상당 수는 `__init__()` 함수에서 타입 시그니처를 첨부하거나 강제하여 해결할 수 있습니다. [9.16장]()을 참고하시기 바랍니다.

*frame hack*이라 불리는 것과 유틸리티 함수를 사용하여 인스턴스 변수를 자동으로 초기화할 수도 있다는 가능성에 주목해야합니다.

```python
def init_fromlocals(self):
    import sys
    locs = sys._getframe(1).f_locals
    for k, v in locs.items():
        if k != 'self':
            setattr(self, k, v)

class Stock:
    def __init__(self, name, shares, price):
        init_fromlocals(self)
```

이 변형에서 `init_fromlocals()` 함수는 `sys._getframe()`을 사용하여 호출하는 메서드의 로컬 변수를 살펴 봅니다.
만일 `__init__()` 메서드의 첫번째 단계로 사용될 경우 로컬 변수는 전달된 인수와 동일하므로 쉽게 동일한 이름의 속성을 설정하는데 사용될 수 있습니다.
비록 이 접근이 IDE의 올바른 호출 서명을 얻는 문제를 피할 수 있지만 이 장에서 제공되는 Solution보다 50% 느리게 동작하며 많은 타이핑을 요구하고 더 정교한 비밀이 숨어있습니다.
코드에 이런 추가 기능이 필요하지 않은 경우 종종 간단한 방법이 잘 작동할 수 있을 것입니다.

## 8.12. Defining an Interface or Abstract Base Class

#### Problem

타입 체킹을 수행할 수 있는 *interface* 또는 *abstract* 기본 클래스로 쓰이는 클래스를 정의하고 특정 메서드가 서브 클래스에서 구현 되는지 확인하려고 합니다.

#### Solution

*abstract* 기본 클래스를 정의하려면 `abc` 모듈을 사용합니다.

```python
from abc import ABCMeta, abstractmethod

class IStream(metaclass=ABCMeta):
    @abstractmethod
    def read(self, maxbytes=-1):
        pass
    @abstractmethod
    def write(self, data):
        pass
```

*abstract* 기본 클래스의 주요 특징은 직접 인스턴스화 할 수 없다는 것입니다.
예를 들어 다음을 시도하면 에러가 발생합니다.

```python
# TypeError: Can't instantiate abstract class
# IStream with abstract methods read, write
a = IStream()
```

대신 *abstract* 기본 클래스는 필수 메서드를 구현할 것으로 예상되는 다른 클래스의 기본 클래스로 사용됨을 의미합니다.

```python
class SocketStream(IStream):
    def read(self, maxbytes=-1):
        ...

    def write(self, data):
        ...
```

*abstract* 기본 클래스의 주된 사용은 예상되는 프로그래밍 *interface*를 강제하고자 하는 코드에 있습니다.
예를 들어, `IStream` 기본 클래스를 보는 한가지 방법은 데이터 읽기 및 쓰기를 허용하는 *interface*에 대한 높은 레벨의 명세로써 보는 것입니다.
명시적으로 이 *interface*를 체크하는 코드는 다음과 같이 쓰일 수 있습니다.

```python
def serialize(obj, stream):
    if not isinstance(stream, IStream):
        raise TypeError('Expected an IStream')
    ...
```

이러한 유형의 타입 체킹은 *abstract* 베이스 클래스(`ABC`)를 서브클래싱해야만 작동한다고 생각할 수 있지만 `ABC`는 다른 클래스를 필수 *interface*로 등록할 수 있습니다.
예를 들어 다음과 같이 할 수 있습니다.

```python
import io

# Register the built-in I/O classes as supporting our interface
IStream.register(io.IOBase)

# Open a normal file and type check
f = open('foo.txt')
isinstance(f, IStream)      # Returns True
```

`@abstractmethod`가 *static* 메서드, 클래스 메서드 및 *property*에도 적용될 수 있다는 사실에 주목해야합니다.
아래와 같이 함수 정의 바로 앞에 `@abstractmethod`가 나타나는 적절한 순서로 적용해야 함을 꼭 확인해야합니다.

```python
from abc import ABCMeta, abstractmethod

class A(metaclass=ABCMeta):
    @property
    @abstractmethod
    def name(self):
        pass

    @name.setter
    @abstractmethod
    def name(self, value):
        pass

    @classmethod
    @abstractmethod
    def method1(cls):
        pass

    @staticmethod
    @abstractmethod
    def method2():
        pass
```

#### Discussion

미리 정의된 *abstract* 기본 클래스는 표준 라이브러리의 여러 곳에서 찾아 볼 수 있습니다.
`collections` 모듈은 `container`와 `iterator`(`sequence`, `map`, `set` 등)가 관련된 다양한 `ABC`를 정의하고, `numbers` 라이브러리는 수 객체(`integer`, `float`, `rational` 등)와 관련된 `ABC`를 정의하며 `io` 라이브러리는 I/O 핸들링과 관련된 `ABC`를 정의합니다.

좀 더 일반적인 종류의 타입 체킹을 수행하기 위해 미리 정의된 `ABC`를 사용할 수 있습니다.
다음은 예제입니다.

```python
import collections

# Check if x is a sequence
if isinstance(x, collections.Sequence):
    ...

# Check if x is iterable
if isinstance(x, collections.Iterable):
    ...

# Check if x has a size
if isinstance(x, collections.Sized):
    ...

# Check if x is a mapping
if isinstance(x, collections.Mapping):
    ...
```

위와 같이 쓰면서 특정 라이브러리 모듈은 미리 정의된 `ABC`를 사용하지 않는다는 점에 유의해야합니다.

```python
from decimal import Decimal
import numbers

x = Decimal('3.4')
isinstance(x, numbers.Real)     # Returns False
```

`3.4`라는 값이 수학적으로 실수일지라도 `floating point` 수와 `decimal`을 부주의하게 섞는 것을 방지하는 방법으로 타입 체크를 하지 않습니다. 그러므로 `ABC` 기능을 사용한다면 행동이 의도한 대로인지 확인하는 테스트를 주의 깊게 작성하는 것이 현명한 방법입니다.

`ABC`는 타입 체킹을 용이하게 하지만, 프로그램에서 남용해야 하는 것도 아닙니다. Python은 유연성(flexibility)이 뛰어난 동적 언어입니다.
타입 제약 조건을 모든 곳에서 강제로 시도하면 코드 결과가 필요 이상으로 복잡해지는 경향이 있습니다.
Python의 유연성을 받아들이는 것이 좋습니다.

## 8.13. Implementing a Data Model or Type System

#### Problem

다양한 종류의 데이터 구조를 정의하려고 하지만 특정 속성에 할당이 허용되는 값의 제약 조건을 강제하려고 합니다.

#### Solution

이 문제에서는 기본적으로 특정 인스턴스 속성 설정에 체크 또는 `assertion`을 두는 작업에 직면하게 됩니다.
이를 위해 `per-attribute basis` 의 속성 설정을 커스터마이즈 해야합니다. 이를 위해서는 *descriptor*를 사용해야 합니다.

다음 코드는 시스템 타입을 구현하고 프레임워크의 값 체킹을 위해 *descriptor*를 사용합니다.

```python
# Base class. Uses a descriptor to set a value
class Descriptor:
    def __init__(self, name=None, **opts):
        self.name = name
        for key, value in opts.items():
            setattr(self, key, value)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

# Descriptor for enforcing types
class Typed(Descriptor):
    expected_type = type(None)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError('expected ' + str(self.exptected_type))
        super().__set__(instance, value)

# Descriptor for enforing values
class Unsigned(Descriptor):
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError('Expected >= 0')
        super().__set__(instance, value)

class MaxSized(Descriptor):
    def __init__(self, name=None, **opts):
        if 'size' not in opts:
            raise TypeError('missing size option')
        super().__init__(name, **opts)

    def __set__(self, instance, value):
        if len(value) >= self.size:
            raise ValueError('Size must be < ' + str(self.size))
        super().__set__(instance, value)
```

이러한 클래스는 데이터 모델 또는 타입 시스템을 구성하는 기본적인 빌딩 단위로 간주되어야 합니다.
계속해서, 다음은 다음은 다른 종류의 데이터를 구현하는 코드입니다.

```python
class Integer(Typed):
    expected_type = int

class UnsignedInteger(Integer, Unsigned):
    pass

class Float(Typed):
    expected_type = float

class UnsignedFloat(Float, Unsigned):
    pass

class String(Typed):
    expected_type = str

class SizedString(String, MaxSized):
    pass
```

이런 타입 객체들의 사용하여 이제 다음과 같은 클래스를 정의합니다.

```python
class Stock:
    # Specify constraints
    name = SizedString('name', size=8)
    shares = UnsignedInteger('shares')
    price = UnsignedFloat('price')
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

제약 조건을 적용하면 속성의 할당이 유효한지 확인될 것입니다.

```python
>>> s = Stock('ACME', 50, 91.1)
>>> s.name
'ACME'
>>> s.shares = 75
>>> s.shares = -10
ValueError: Expected >= 0
>>> s.price = 'a lot'
TypeError: expected <class 'float'>
>>> s.name = "ABRACADABRA'
ValueError: size must be < 8
```

클래스에서 제약 조건 지정을 단순화하는 데 사용될 수 있는 몇가지 기술이 있습니다. 한 접근법은 클래스 *decorator*를 다음과 같이 사용하는 것입니다.

```python
# Class decorator to apply constraints
def check_attributes(**kwargs):
    def decorate(cls):
        for key, value in kwargs.items():
            if isinstance(value, Descriptor):
                value.name = key
                setattr(cls, key, value)
            else:
                setattr(cls, key, value(key))
        return cls
    return decorate

# Example
@check_attributes(name=SizedString(size=8), shares=UnsignedInteger, price=UnsignedFloat)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

제약 조건을 단순화하는 또 다른 방법은 *metaclass*를 사용하는 것입니다.

```python
# A metaclass that applies checking
class checkedmeta(type):
    def __new__(cls, clsname, bases, methods):
        # Attach attribute names to the descriptors
        for key, value in methods.items():
            if isinstance(value, Descriptor):
                value.name = key
        return type.__new__(cls, clsname, bases, methods)

# Example
class Stock(metaclass=checkedmeta):
    name = SizedString(size=8)
    shares = UnsignedInteger()
    price = UnsignedFloat()
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

#### Discussion

이 장은 *descriptor*, *mixin* 클래스, `super()`의 사용, *decorator* 클래스와 *metaclass* 사용을 포함하는 많은 고급 기술이 사용됩니다.
모든 토픽의 기본을 다루는 것은 여기에서 다룰 수 있는 것 이상이지만 다른 장([8.9](#89-creating-a-new-kind-of-class-or-instance-attribute), [8.18](#818-extending-classes-with-mixins), [9.12](), [9.19]())에서도 찾아 볼 수 있습니다. 하지만 많은 미묘한 부분들에 주목할 가치가 있습니다.

첫 번째로, `Descriptor` 기본 클래스에선 `__set__()` 메서드가 있지만 `__get__()`은 없다는 것을 알 수 있습니다.
*descriptor*가 기본 인스턴스 `dictionary`에서 동일한 이름의 값을 추출하는 것 이상을 수행하지 않는다면 `__get__()`을 정의하는 것이 불필요합니다. 사실 `__get__()`을 정의하는 것은 동작을 느리게합니다. 그러므로 이 장에서 `__set__()` 구현에만 초점을 맞춥니다.

다양한 *descriptor* 클래스의 전반적인 디자인은 *mixin* 클래스를 기반으로합니다.
예를 들어 `Unsigned`와 `MaxSized` 클래스는 `Typed`에서 파생된 다른 *descriptor* 클래스와 섞일 수 있도록 되어 있습니다.
특정 종류의 데이터 타입을 핸들하기 위해 다중 상속을 사용하여 원하는 기능을 결합하여 사용합니다.

또한 다양한 *descriptor*의 모든 `__init__()` 메서드가 키워드 인수 `**opts`와 동일한 시그니처를 갖도록 프로그래밍 되었다는 것을 알 수 있습니다.
`MaxSized`의 클래스는 `opts`에서 필수 속성을 찾지만 실제로 그것을 설정하는 `Descriptor`의 기본 클래스에 전달합니다.
이와 같은 클래스를 구성하는 데 있어 까다로운 부분 중 하나는(특히 *mixin*) 클래스가 어떻게 함께 연결되는 지 또는 `super()`가 호출될 것인지를 항상 알 수는 없다는 것입니다.
이런 이유로 가능한 모든 클래스의 조합으로 동작하게 해야 합니다.

`Integer`, `Float`, `String` 같은 다양한 타입 클래스의 정의는 구현을 커스터마이즈 하기 위한 클래스 변수 사용으로 유용한 기술을 설명합니다. `Typed` *descriptor*는 단지 각 서브클래스에 의해 제공되는 `expected_type` 속성을 찾습니다.

클래스 *decorator* 또는 *metaclass*의 사용은 종종 사용자가 명세를 단순화하는 데 유용합니다.
이런 예제에서 사용자는 더 이상 속성의 이름을 한 번을 초과하여 입력할 필요가 없습니다.

```python
# Normal
class Point:
    x = Integer('x')
    y = Integer('y')

# Metaclass
class Point(metaclass=checkedmeta):
    x = Integer()
    y = Integer()
```

클래스 *decorator*와 *metaclass* 코드는 단순히 `dictionary`를 검색하여 *descriptor*를 찾습니다.
찾았을 때는 키 값을 기반으로 *descriptor* 이름을 채웁니다.

모든 접근 방식 중, 클래스 *decorator* Solution은 가장 좋은 유연성과 온전성(sanity)를 제공할 수 있습니다.
하나는 *metaclass*와 같은 고급 기술에 의존하지 않습니다.
두번째로 *decoration*이 원하는 대로 쉽게 클래스 정의에 추가하거나 제거할 수 있다는 것입니다.
예를 들어 *decorator* 내에서 단순히 추가된 검사를 생략하는 옵션이 있을 수 있습니다.
이들은 검사가 요구에 따라 켜거나 끌 수 있는 어떤 것일 수 있습니다(디버깅용 vs 배포용).

마지막으로 클래스 *decorator* 접근은 *mixin* 클래스, 다중 상속, 그리고 `super()` 함수의 까다로운 사용을 대신 할 수도 있습니다.
다음은 클래스 *decorator*를 사용하는 이 장 수식의 대안입니다.

```python
# Base class. Uses a descriptor to set a value
class Descriptor:
    def __init__(self, name=None, **opts):
        self.name = name
        for key, value in opts.items():
            setattr(self, key, value)

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value

# Decorator for applying type checking
def Typed(expected_type, cls=None):
    if cls is None:
        return lambda cls: Typed(expected_type, cls)

    super_set = cls.__set__
    def __set__(self, instance, value):
        if not isinstance(value, expected_type):
            raise TypeError('expected ' + str(expected_type))
        super_set(self, instance, value)
    cls.__set__ = __set__
    return cls

# Decorator for unsigned values
def Unsigned(cls):
    super_set = cls.__set__
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError('Expected >= 0')
        super_set(self, instance, value)
    cls.__set__ = __set__
    return cls

# Decorator for allowing sized values
def MaxSized(cls):
    super_init = cls.__init__
    def __init__(self, name=None, **opts):
        if 'size' not in opts:
            raise TypeError('missing size option')
        super_init(self, name, **opts)
    cls.__init__ = __init__

    super_set = cls.__set__
    def __set__(self, instance, value):
        if len(value) >= self.size:
            raise ValueError('size must be < ' + str(self.size))
        super_set(self, instance, value)
    cls.__set__ = __set__
    return cls

# Specialized descriptors
@Typed(int)
class Integer(Descriptor):
    pass

@Unsigned
class UnsignedInteger(Integer):
    pass

@Typed(float)
class Float(Descriptor):
    pass

@Unsigned
class UnsignedFloat(Float):
    pass

@Typed(str)
class String(Descriptor):
    pass

@MaxSized
class SizedString(String):
    pass
```

이 대안 수식에서 정의된 클래스는 모든 것이 훨씬 빠르게 실행된다는 점을 제외하고는 이전과 완전히 똑같은 방식으로 작동합니다(이전 예제 코드 변화는 없습니다).

예를 들어 타이핑된 속성을 설정하는 간단한 타이밍 테스트는 클래스 *decorator* 방식으로 접근하는 것이 *mixin* 방식을 사용해서 접근하는 보다 거의 100% 빠르게 실행된다는 것을 나타냅니다.

## 8.14. Implementing Custom Containers

#### Problem

`list`나 `dictionary` 같은 일반 *built-in* 컨테이너 타입의 동작을 모방한 커스텀 클래스를 구현하려고 합니다.

#### Solution

`collections` 라이브러리는 커스텀 컨테이너 클래스를 구현할 때 매우 유용한 다양한 *abstract* 기본 클래스를 정의합니다.
설명을 위해 클래스가 iteration을 지원한다고 가정합니다.
그렇게 하려면 먼저 `collection.Itarable`에서 상속을 받는 것 부터 시작해야 합니다.

```python
import collections

class A(collections.Iterable):
    pass
```

`collections.Iterable`에서 상속하는 특별한 기능은 필요한 모든 특수 메서드의 구현을 보장한다는 것입니다.
그렇지 않으면 인스턴스 생성 시 에러가 발생합니다.

```python
>>> a = A()
TypeError: Cannot instantiate abstract class A with abstract method __iter__
```

에러를 해결하기 위해 클래스에 필요한 `__iter__()` 메서드를 제공하고 원하는 대로 구현합니다([4.2장](/2017/01/05/py-cook-4.html#42-delegating-iteration) 및 [4.7장](/2017/01/05/py-cook-4.html#47-taking-a-slice-of-an-iterator) 참조).

`collections`에 정의된 다른 주목할만한 클래스는 `Sequence`, `MutableSequence`, `Mapping`, `MutableMapping`, `Set`, `MutableSet`입니다.
이러한 클래스 중 다수는 기능의 레벨이 증가하는 계층 구조를 형성합니다(이런 계층 구조는 `Container`, `Iterable`, `Sized`, `Sequence`, `MutableSequence`가 있습니다).
다시 말해 이러한 클래스를 인스턴스화하면 해당 동작을 사용하여 커스텀 컨테이너를 만들기 위해 어떤 메서드를 구현해야 하는지 확인할 수 있습니다.

```python
>>> import collections
>>> collections.Sequence()
TypeError: Cannot instantiate abstract class Sequence with abstrace methods
__getitem__, __len__
```

다음은 항목이 항상 정렬된 순서로 저장되는 `sequence`를 만드는 앞의 메서드를 구현하는 클래스의 간단한 예제입니다(특별히 효율적인 구현은 아니지만 일반적인 아이디어를 보여줍니다).

```python
import collections
import bisect

class SortedItems(collections.Sequence):
    def __init__(self, initial=None):
        self._items = sorted(initiali if initial is None else [])

    # Required sequence methods
    def __getitem__(self, index):
        return self._items[index]

    def __len__(self):
        return len(self._items)

    # Method for adding an item in the right location
    def add(self, item):
        bisect.insort(self._items, item)
```

다음은 이 클래스 사용의 예제입니다.

```python
>>> items = SortedItems([5, 1, 3])
>>> list(items)
[1, 3, 5]
>>> items[0]
1
>>> items[-1]
5
>>> items.add(2)
>>> list(items)
[1, 2, 3, 5]
>>> items.add(-10)
>>> list(items)
[-10, 1, 2, 3, 5]
>>> items[1:4]
[1, 2, 3]
>>> 3 in items
True
>>> len(items)
5
>>> for n in items:
...     print(n)
...
-10
1
2
3
5
```

보시다시피 `SortedItems`의 인스턴스는 정상적인 `sequence`와 똑같이 동작하며 indexing, iteration, `len()`, containment(`in` 연산자) 및 slicing 작업도 모두 지원합니다.

또한 이 장에서 사용된 `bisect` 모듈은 항목을 정렬된 `list`로 유지하는 편리한 방법입니다.
`bisect.insort()`는 항목을 `list`에 삽입하여 목록이 순서대로 유지되도록 합니다.

`collections`에서 *abstract* 기본 클래스 중 하나를 상속하면 커스텀 컨테이너가 컨테이너에 필요한 모든 필수 메서드 구현을 보장합니다.
하지만 이 상속은 또한 타입 체킹도 진행합니다.

예를 들어 커스텀 컨테이너가 다음과 같이 다양한 타입 체크를 만족할 것입니다.

```python
>>> items = SortedItems()
>>> import collections
>>> isinstance(items, collections.Iterable)
True
>>> isinstance(items, collections.Sequence)
True
>>> isinstance(items, collections.Container)
True
>>> isinstance(items, collections.Sized)
True
>>> isinstance(items, collections.Mapping)
False
```

`collections`에서 다수의 *abstract* 기본 클래스는 또한 일반 컨테이너 메서드의 기본 구현을 제공하기도 합니다.
예를 들면 `collections.MutableSequence`를 상속하는 클래스가 있다고 다음과 같이 가정합니다.

```python
class Items(collections.MutableSequence):
    def __init__(self, initial=None):
        self._items = list(initial) if initial is None else []

    # Required sequence methods
    def __getitem__(self, index):
        print('Getting:', index)
        return self._items[index]

    def __setitem__(self, index, value):
        print('Setting:', index, value)
        self._items[index] = value

    def __delitem__(self, index):
        print('Deleting:', index)
        def self._items[index]

    def insert(self, index, value):
        print('Inserting:', index, value)
        self._items.insert(index, value)

    def __len__(self):
        print('Len')
        return len(self._items)
```

`Items` 인스턴스를 생성하면 거의 모든 핵심 `list` 메서드(`append()`, `remove()`, `count()` 등)를 지원한다는 것을 알 수 있습니다. 이런 메서드들은 필요한 것만 사용하는 방식으로 구현됩니다. 다음은 대화식 세션으로 이를 설명합니다.

```python
>>> a = Items([1, 2, 3])
>>> len(a)
Len
3
>>> a.append(4)
Len
Inserting: 3 4
>>> a.append(2)
Len
Inserting: 4 2
>>> a.count(2)
Getting: 0
Getting: 1
Getting: 2
Getting: 3
Getting: 4
Getting: 5
2
>>> a.remove(3)
Getting: 0
Getting: 1
Getting: 2
Deleting: 2
```

이 장에서는 Python의 *abstract* 클래스 기능에 대해서만 간략하게 제공합니다.
`numbers` 모듈은 수 데이터 타입과 관련된 *abstract* 클래스의 유사한 컬렉션을 제공합니다.
[8.12장](#812-defining-an-interface-or-abstract-base-class)에 *abstract* 기본 클래스를 생성하는 자세한 정보를 참조하시기 바랍니다.

## 8.15. Delegating Attribute Access

#### Problem

인스턴스의 상속의 대안이나 *proxy*를 구현하기 위해 내부적으로 보유된 인스턴스에 대한 속성 액세스를 *delegate*(위임)하려고 합니다.

#### Solution

간단히 말해서 위임은 특정 작업을 구현하는 책임이 다른 객체로 전달되는(위임)되는 프로그래밍 패턴입니다.
가장 간단한 형태는 다음과 같이 나타납니다.

```python
class A:
    def spam(self, x):
        pass

    def foo(self):
        pass

class B:
    def __init__(self):
        self._a = A()

    def spam(self, x):
        # Delegate to the inteernal self._a instance
        return self._a.spam

    def foo(self):
        # Delegate to the internal self._a instance
        return self._a.foo()

    def bar(self):
        pass
```

위임할 수 있는 메서드가 몇 개 없다면 주어진 코드를 작성하는 것 만으로도 충분합니다.
하지만 위임할 수 있는 많은 메서드가 있다면 대안으로 `__getattr__()` 메서드를 정의하는 것으로 다음과 같이 접근합니다.

```python
class A:
    def spam(self, x):
        pass

    def foo(self):
        pass

class B:
    def __init__(self):
        self._a = A()

    def bar(self):
        pass

    # Expose all of the methods defined on class A
    def __getattr__(self, name):
        return getattr(self._a, name)
```

`__getattr__()` 메서드는 속성 조회를 위한 포괄적인 개념입니다.
**코드가 존재하지 않는 속성에 액세스하려고 할 경우에 호출되는 메서드입니다.**
이전 코드에서 `B`에서 정의되지 않은 메서드에 대한 액세스를 캐치하고 간단하게 `A`에 위임합니다.

```python
b = B()
b.bar()     # Calls B.bar() (exists on B)
b.spam(42)  # Calls B.__getattr__('spam') and delegates to A.spam
```

위임의 또 다른 예제는 *proxy*의 구현에 있습니다.

```python
# A proxy class that wraps around another object, but exposes its public attributes

class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        print('getattr:', name)
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            print('setattr:', name, value)
            setattr(self._obj, name, value)

    # Delegate attribute deletion
    def __delattr__(self, name):
        if name.startswith('_'):
            super().__delattr__(name)
        else:
            print('delattr:', name)
            delattr(self._obj, name)
```

이 *proxy* 클래스를 사용하려면 다른 인스턴스로 `wrap`하면 됩니다.

```python
class Spam:
    def __init__(self, x):
        self.x = x

    def bar(self, y):
        print('Spam.bar:', self.x, y)

# Create an instance
s = Spam(2)

# Create a proxy around it
p = Proxy(s)

# Access the proxy
print(p.x)      # 2
p.bar(3)        # "Spam.bar: 2 3"
p.x = 37        # Changes s.x to 37
```

속성 메서드 구현을 커스터마이징 함으로써 *proxy*를 다른 방식으로 커스터마이즈 할 수 있습니다(액세스 로깅, 읽기 전용 액세스만 허용 등).

#### Discussion

위임은 가끔 상속의 대안으로 사용됩니다. 예를 들어 다음과 같은 코드로 대신 작성합니다.

```python

class A:
    def spam(self, x):
        print('A.spam', x)

    def foo(self):
        print('A.foo')

class B(A):
    def spam(self, x):
        print('B.spam')
        super().spam(x)

    def bar(self):
        print('B.bar')
```

위임과 관련된 Solution은 다음과 같이 작성됩니다.

```python
class A:
    def spam(self, x):
        print('A.spam', x)

    def foo(self):
        print('A.foo')

class B:
    def __init__(self):
        self._a = A()

    def spam(self, x):
        print('B.spam', x)
        self._a.spam(x)

    def bar(self):
        print('B.bar')

    def __getattr__(self, name):
        return getattr(self._a, name)
```

이 위임을 사용하면 직접 상속이 별로 의미가 없거나 객체 간의 관계를 잘 제어하려는 경우에 유용합니다(특정 메서드 노출, 인터페이스 구현 등).

위임을 사용하여 *proxy*를 구현할 때 알아야 할 몇 가지 추가 세부 사항이 있습니다.
첫 번째로 `__getattr__()` 메서드는 실제로 속성을 찾을 수 없을 때 호출되는 *fallback*(대체) 메서드입니다.
그러므로 *proxy* 인스턴스 자체의 속성에 액세스 될 때(위 *proxy*의 `_obj` 속성) 이 메서드가 트리거되진 않습니다.
두 번째로, `__setattr__()`와 `__delattr__()` 메서드는 *proxy* 인스턴스 자체와 내부 객체 `_obj`의 속성으로부터 별도의 속성으로 추가하기 위해 약간의 추가 로직이 필요합니다.
**일반적인 규칙은 *proxy*가 맨 앞의 밑줄로 시작하지 않는 속성에만 위임하는 것입니다**(즉 보유한 인스턴스의 *public* 속성만 노출합니다).

`__getattr__()` 메서드는 보통 이중 밑줄로 시작하고 끝나는 대부분의 특수 메서드에는 적용되지 않는다는 점도 중요합니다. 예를 들어 다음 클래스를 고려합니다.

```python
class ListLike:
    def __init__(self):
        self._items = []

    def __getattr__(self, name):
        return getattr(self._items, name)
```

`ListLike` 객체를 만들려고 하면 `append()` 및 `insert()`와 같은 일반 `list` 메서드를 지원한다는 것을 알 수 있습니다.
하지만 `len()`, 항목 탐색 등과 같은 연산은 지원하지 않습니다.

```python
>>> a = ListLike()
>>> a.append(2)
>>> a.insert(0, 1)
>>> a.sort()
>>> len(a)
TypeError: 'ListLike' has no len()
>>> a[0]
TypeError: 'ListLike' object does not support indexing
```

다른 연산을 지원하려면 관련된 특수 메서드 자체를 수동적으로 위임해야합니다.

```python
class ListLike:
    def __init__(self):
        self._items = []
    
    def __getattr__(self, name):
        return getattr(self._items, name)

    # Added special methods to support certain list operations
    def __len__(self):
        return len(self._items)

    def __getitem__(self, index):
        return self._items[index]
    
    def __setitem__(self, index, value):
        self._items[index] = value

    def __delitem__(self, index):
        del self._items[index]
```

[11.8장]()에 원격 프로시저 호출을 위한 *proxy* 클래스 생성 컨텍스트에서 위임을 사용하는 또 다른 예제를 참조하시기 바랍니다.

## 8.16. Defining More Than One Constructor in a Class

#### Problem

클래스를 작성하고 있지만 사용자가 `__init__()`에서 제공하는 한 가지 이상의 방법으로 인스턴스를 만들 수 있게 하려고 합니다.

#### Solution

한 가지 이상의 *constructor*를 가진 클래스를 정의하려면 클래스 메서드를 사용해야 합니다. 다음은 간단한 예제입니다.

```python
import time

class Date:
    # Primary constructor
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    # Alternate constructor
    @classmethod
    def today(cls):
        t = time.localtime()
        return cls(t.tm_year, t.tm_mon, t.tm_mday)
```

대체 *constructor*를 사용하려면 `Date.today()`와 같은 함수로 호출하기만 하면 됩니다. 다음은 예제입니다.

```python
a = Date(2012, 12, 21)      # Primary
b = Date.today()            # Alternate
```

#### Discussion

클래스 메서드의 주된 용도 중 하나는 이 장에서 볼 수 있듯 대체 *constructor*를 정의하는 것입니다.
클래스 메서드의 필수적인 기능은 클래스를 첫 번째 인수(`cls`)로 받는 것입니다.
이 클래스는 메서드 내에서 최종 인스턴스를 만들고 리턴하는 데 사용됩니다.
아주 미묘하지만 클래스 메서드의 이러한 측면은 상속과 같은 기능에도 올바르게 동작합니다.

```python
class NewDate(Date):
    pass

c = Date.today()        # Creates an instance of Date (cls=Date)
d = NewDate.today()     # Creates an instance of NewDate (cls=NewDate)
```

다중 *constructor*로 클래스를 정의할 때는 `__init__()` 함수를 가능한 한 단순하게 만들어야 합니다. 주어진 값에서 속성을 할당하는 것 이상을 수행하지 않아야 합니다.
대체 *constructor*는 필요한 경우 고급 작업을 수행하도록 선택할 수 있습니다.

클래스 메서드를 나누어 정의하는 대신에 `__init__()` 메서드를 다른 호출 규칙을 허용하는 방식으로 구현하는 경향이 있을 수도 있습니다.

```python
class Date:
    def __init__(self, *args):
        if len(args) == 0
            t = time.localtime()
            args = (t.tm_year, t.tm_mon, t.tm_mday)
        self.year, self.month, self.day = args
```

이 기법은 특정 케이스에 동작하지만 종종 코드가 이해하기 힘들고 유지하기 어려운 코드로 이어집니다.
예를 들어 이 구현은 유용한 도움말 문자열(인수 이름 포함)을 표시하지 않습니다.
추가로 `Date` 인스턴스를 만드는 코드가 덜 명확합니다. 다음과 비교 대조 해보시기 바랍니다.

```python
a = Date(2012, 12, 21)  # Clear. A specific date
b = Date()              # ??? What does this do?

# Class method version
c = Date.today()        # Clear. Today's Date.
```

보시다시피 `Date.today()`는 적절한 연, 월, 일 인수와 함께 `Date()`를 인스턴스화하여 일반 `Date.__init__()` 메서드를 호출합니다.
필요하다면 `__init__()` 메서드 호출 없이도 인스턴스를 생성할 수도 있습니다. 이는 다음 장에서 다룹니다.

## 8.17. Creating an Instance Without Invoking *init*

#### Problem

인스턴스를 생성해야 하지만 어떤 이유로 `__init__()` 메서드의 실행을 우회하려고 합니다.

#### Solution

거의 완전히 초기화되지 않은 인스턴스는 클래스의 `__new__()` 메서드를 직접 호출하여 생성할 수 있습니다.
예를 들어 다음 클래스를 고려합니다.

```python
class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
```

다음은 `Date` 인스턴스를 `__init__()` 호출 없이 생성할 수 있는 방법입니다.

```python
>>> d = Date.__new__(Date)
>>> d
<__main__.Date object at 0x1006716d0>
>>> d.year
AttributeError: 'Date' object has no attribute 'year'
```

보시다시피 결과 인스턴스가 초기화 되지 않았습니다. 그러므로 적절한 인스턴스 변수를 설정하는 것은 이제 사용자의 책임입니다.

```python
>>> data = {'year': 2012, 'month': 8, 'day': 29}
>>> for key, value in data.items():
...     setattr(d, key, value)
...
>>> d.year
2012
>>> d.month
8
```

#### Discussion

`__init__()`을 우회하는 경우는 데이터를 *deserialize*하거나 대체 *constructor*로 정의된 클래스 메서드 구현에서 인스턴스를 비 표준 방식으로 생성할 때 가끔 발생합니다.
예를 들어 `Date` 클래스를 대체 *constructor*인 `today()`로 다음과 같이 정의할 수도 있습니다.

```python
from time import localtime

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    @classmethod
    def today(cls):
        d = cls.__new__(cls)
        t = localtime()
        d.year = t.tm_year
        d.month = t.tm_mon
        d.day = t.tm_mday
        return d
```

마찬가지로 JSON 데이터를 *deserialize* 하고 결과적으로 다음과 같은 `dictionary`를 생성한다고 가정합니다.

```python
data = {'year': 2012, 'month': 8, 'day': 29}
```

이를 `Date` 인스턴스로 바꾸러면 Solution에 나타낸 기술을 사용하기만 하면 됩니다.

비 표준적인 방법으로 인스턴스를 생성할 때는 보통 구현에 대해 너무 많은 가정을 하지 않는 것이 좋습니다.
또한 정의된 것이 확실하지 않다면 일반적으로 기본 인스턴스 `dictionary`인 `__dict__`를 직접 조작하는 코드를 작성하지 않길 원할 것입니다.
아니면 클래스가 `__slots__`, *property*, *descriptor* 또는 다른 고급 기술을 사용할 경우 코드가 중단될 것입니다.
값을 설정하는 데 `setattr()`을 사용함으로써 코드가 가능한 한 범용적으로 사용될 것입니다.

## 8.18. Extending Classes with Mixins

#### Problem

다른 클래스 정의의 기능을 확장하는 데 일반적으로 유용한 메서드의 컬렉션이 있습니다.
하지만 추가될 수 있는 메서드의 클래스가 꼭 상속으로 서로 연관될 필요는 없습니다.
따라서 일반 기본 클래스에 메서드를 첨부할 수는 없습니다.

#### Solution

이 장에서 다루는 문제는 종종 클래스 커스텀 문제에 관심이 있는 코드에서 발생합니다.
예를 들어 라이브러리는 사용자가 원할 경우 적용할 수 있는 일련의 선택적 커스텀과 함께 기본 클래스들을 제공합니다.
설명을 위해 객체를 매핑하기 위한 다양한 커스텀 추가에 관심이 있다고 가정합니다(로깅, 일회성 설정, 타입 체킹 등).
다음은 일련의 *mixin* 클래스입니다.

```python
class LoggedMappingMixin:
    '''
    Add logging to get/set/delete options for debugging.
    '''
    __slots__ = ()

    def __getitem__(self, key):
        print('Getting ' + str(key))
        return super().__getitem__(key)

    def __setitem__(self, key, value):
        print('Setting {} = {!r}'.format(key, value))
        return super().__setitem__(key, value)

    def __delitem__(self, key):
        print('Deleting ' + str(key))
        return super().__delitem__(key)

class SetOnceMappingMixin:
    '''
    Only allow a key to be set once.
    '''
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)

class StringKeysMappingMixin:
    '''
    Restrict keys to strings only
    '''
    __slots__ = ()

    def __setitem__(self, key, value):
        if not isinstance(key, str):
            raise TypeError('keys must be strings')
        return super().__setitem__(key, value)
```

이런 클래스들이 자체로는 쓸모가 없습니다. 실제로 이들 중 하나가 인스턴스화 되면 전혀 도움이 되지 않습니다(예외 생성 제외).
대신 다중 상속을 통해 다른 매핑 클래스와 섞여 있어야 합니다.

```python
>>> class LoggedDict(LoggedMappingMixin, dict):
...     pass
...
>>> d = LoggedDict()
>>> d['x'] = 23
Setting x = 23
>>> d['x']
Getting x
23
>>> del d['x']
Deleting x
>>> from collections import defaultdict
>>> class SetOnceDefaultDict(SetOnceMappingMixin, defaultdict):
...     pass
...
>>> d = SetOnceDefaultDict(list)
>>> d['x'].append(2)
>>> d['y'].append(3)
>>> d['x'].append(10)
>>> d['x'] = 23
KeyError: 'x already set'

>>> from collections import OrderedDict
>>> class StringOrderedDict(StringKeysMappingMixin, SetOnceMappingMixin, OrderedDict):
...     pass
...
>>> d = StringOrderedDict()
>>> d['x'] = 23
>>> d[42] = 10
TypeError: keys must be strings
>>> d['x'] = 42
KeyError: 'x already set'
```

이 예에서 *mixin*은 다른 기존의 클래스와 결합되어있고(예. `dict`, `defaultdict`, `OrderedDict`), 심지어 다른 클래스와도 결합되어 있음을 알 수 있습니다.
결합되면 클래스는 모두 함께 동작하여 원하는 기능을 제공합니다.

#### Discussion

*mixin* 클래스는 표준 라이브러리 여러 곳에서 나타나며 대부분은 보여진 것과 유사하게 다른 클래스의 기능을 확장하는 수단이 됩니다.
또한 다중 상속의 주된 용도 중 하나입니다.
예를 들어 네트워크 코드를 작성한다면 다른 네트워크 관련 클래스들에 스레드 지원을 추가하기 위해 종종 `socketserver` 모듈에서 `ThreadingMixIn`을 사용할 수 있습니다.
예를 들어 다음은 멀티스레드된 XML-RPC 서버입니다.

```python
from xmlrpc.server import SimpleXMLRPCServer
from socketserrver import ThreadingMixIn
class ThreadedXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer):
    pass
```

또한 대규모 라이브러리 및 프레임워크에 정의된 *mixin*을 찾아내는 것이 일반적입니다. 다시말해 선택적 기능을 사용하여 기존 클래스의 기능을 향상시키는 것이 전형적입니다.

*mixin* 클래스의 이론을 둘러싼 풍부한 역사가 있습니다.
하지만 모든 세부 사항을 다루기 보다는 몇가지 중요한 구현 세부 사항을 염두에 두어야 합니다.

첫 번째로 *mixin* 클래스는 절대 직접 인스턴스화 되지 않습니다.
예를 들어 이 장의 클래스 중 어떤 것도 스스로 동작하지 않습니다.
필요한 매핑 기능을 구현하는 다른 클래스와 혼합해야 합니다.
비슷하게 `socketserver` 라이브러리의 `ThreadingMixIn`도 적절한 서버 클래스와 혼합해야 합니다. 단독으로 모두 사용될 수는 없습니다.

두 번째로 *mixin* 클래스는 일반적으로 스스로의 상태를 가지고 있지 않습니다.
이 의미는 `__init__()` 메서드와 인스턴스 변수가 없다는 것입니다.
이 장에서 `__slots__ = ()`의 지정은 *mixin* 클래스라는 강력한 힌트로 쓰이며 스스로의 인스턴스 데이터를 가질 수 없습니다.

`__init__()` 메서드와 인스턴스 변수를 가진 *mixin* 클래스를 정의한다고 생각하면 혼합될 다른 클래스에 대해 알지 못하는 사실과 관련된 큰 위험이 있음에 유의하시기 바랍니다.
그러므로 생성된 모든 인스턴스 변수는 이름 충돌을 피하는 방식으로 이름이 지어져야 합니다.
또한 `__init__()` 메서드는 혼합된 다른 클래스의 `__init__()` 메서드를 적절하게 호출하는 방식으로 프로그래밍되어야 합니다.
일반적으로 다른 클래스의 인수 시그니처에 대해 알 수 없기 때문에 구현하기가 어렵습니다.
최소한 매우 일반적인 `*arg`, `**kwargs`를 사용하여 구현해야 할 것입니다.
*mixin* 클래스의 `__init__()`이 스스로의 인수를 취한 경우 그 인수는 키워드로만 지정되어야 하며 다른 인수와의 이름 충돌을 피하도록 지정되어야 합니다.
다음은 `__init__()`을 정의하고 키워드 인수를 받는 *mixin* 구현입니다.

```python
class RestrictKeysMixin:
    def __init__(self, *args, _restrict_key_type, **kwargs):
        self.__restrict_key_type = _restrict_key_type
        super().__init__(*args, **kwargs)

    def __setitem__(self, key, value):
        if not isinstance(key, self.__restrict_key_type):
            raise TypeError('Keys must be ' + str(self.__restrict_key_type))
        super().__setitem__(key, value)
```

다음은 이 클래스가 사용되는 방법을 보여줍니다.

```python
>>> class RDict(RestrictKeysMixin, dict):
...     pass
...
>>> d = RDict(_restrict_key_type=str)
>>> e = RDict([('name', 'Dave'), ('n', 37)], _restrict_key_type=str)
>>> f = RDict(name='Dave', n=37, _restrict_key_type=str)
>>> f
{'n': 37, 'name': 'Dave'}
>>> f[42] = 10
TypeError: Keys must be <class 'str'>
```

이 예제에서 여전히 `dict()`로 이해된 인수를 취하여 `RDict()`를 초기화 한다는 것을 알 수 있습니다.
하지만 *mixin* 클래스에 제공되는 추가 키워드 인수 `restrict_key_type`가 있습니다.
`super()`를 사용하여 메서드 확인 순서(MRO)에서 다음 클래스에 위임합니다.
하지만 이 장의 이런 측면 초보자에게 분명해 보이지 않습니다. `super()`가 부모가 없는 클래스를 사용 중이기 때문입니다(처음에는 에러로 보일 수 있습니다).
하지만 다음과 같은 클래스 정의에서:

```python
class LoggedDict(LoggedMappingMixin, dict):
    pass
```

`LoggedMappingMixin`에서 `super()`를 사용하면 다중 상속 리스트에서 다음 클래스로 위임됩니다.
즉 `LoggedMappingMixin`에서 `super().__getitem__()`와 같은 호출은 실제로 절차를 밟아서 `dict.__getitem__()`을 호출합니다.
이 동작이 없다면 *mixin* 클래스는 전혀 동작하지 않을 것입니다.

*mixin*의 대체 구현은 클래스 *decorator* 사용이 있습니다.

```python
def LoggedMapping(cls):
    cls_getitem = cls.__getitem__
    cls_setitem = cls.__setitem__
    cls_delitem = cls.__delitem__

    def __getitem__(self, key):
        print('Getting ' + str(key))
        return cls_getitem(self, key)

    def __setitem__(self, key, value):
        print('Setting {} = {!r}'.format(key, value))
        return cls_setitem(self, key, value)

    def __delitem__(self, key):
        print('Deleting ' + str(key))
        return cls_delitem(self, key)

    cls.__getitem__ = __getitem__
    cls.__setitem__ = __setitem__
    cls.__delitem__ = __delitem__
    return cls
```

이 함수는 *decorator*로 클래스 정의에 적용되었습니다.

```python
@LoggedMapping
class LoggedDict(dict):
    pass
```

이를 시도하면 같은 동작을 할 수 있다는 걸 알 수 있지만 다중 상속이 더이상 포함되지 않습니다. 대신 *decorator*가 특정 메서드를 대체하기 위해 클래스 정의에서 약간의 수술이 간단히 수행됩니다. 클래스 *decorator*에 대한 세부 사항은 [9.12장]()에서 찾아 볼 수 있습니다.

*mixin*과 *decorator*를 모두 포함하는 심화 내용은 [8.13장](#813-implementing-a-data-model-or-type-system)을 참고하시기 바랍니다.

## 8.19. Implementing Stateful Objects or State Machines

#### Problem

상태 머신이나 여러 상태에서 동작하는 객체를 구현하려고 하지만 많은 조건문으로 코드를 낭비하지 않으려고 합니다.

#### Solution

어떤 애플리케이션에서는 일종의 내부 상태에 따라 다르게 동작하는 객체가 있을 수 있습니다.
예를 들어 연결을 표현하는 간단한 클래스를 고려합니다.

```python
class Connection:
    def __init__(self):
        self.state = 'CLOSED'

    def read(self):
        if self.state != 'OPEN':
            raise RuntimeError('Not open')
        print('reading')

    def write(self, data):
        if self.state != 'OPEN':
            raise RuntimeError('Not open')
        print('writing')

    def open(self):
        if self.state == 'OPEN':
            raise RuntimeError('Already open')
        self.state = 'OPEN'

    def close(self):
        if self.state == 'CLOSED':
            raise RuntimeError('Already closed')
        self.state = 'CLOSED'
```

이 구현에는 몇 가지 어려움이 있습니다.
첫 번째로 코드가 상태에 대한 많은 조건 검사를 도입함으로써 복잡해 졌습니다.
두 번째로 성능이 저하됩니다. 일반적인 작업(`read()`와 `write()`)이 항상 진행 전에 상태를 체크하기 때문입니다.

좀 더 우아한 접근은 각 동작 상태를 별도의 클래스로 인코딩하고 `Connection` 클래스를 상태 클래스로 위임하도록 정렬하는 것입니다.

```python
class Connection:
    def __init__(self):
        self.new_state(ClosedConnectionState)

    def new_state(self, newstate):
        self._state = newstate

    # Delegate to the state class
    def read(self):
        return self._state.read(self)

    def write(self, data):
        return self._state.write(self, data)

    def open(self):
        return self._state.open(self)

    def close(self):
        return self._state.close(self)

# Connection state base class
class ConnectionState
    @staticmethod
    def read(conn):
        raise NotImplementedError()

    @staticmethod
    def write(conn, data):
        raise NotImplementedError()

    @staticmethod
    def open(conn):
        raise NotImplementedError()

    @staticmethod
    def close(conn):
        raise NotImplementedError()

# Implementation of different states
class ClosedConnectionState(ConnectionState):
    @staticmethod
    def read(conn):
        raise RuntimeError('Not open')

    @staticmethod
    def write(conn):
        raise RuntimeError('Not open')

    @staticmethod
    def open(conn):
        conn.new_state(OpenConnectionState)

    @staticmethod
    def close(conn):
        raise RuntimeError('Already closed')

class OpenConnectionState(ConnectionState):
    @staticmethod
    def read(conn):
        print('reading')

    @staticmethod
    def write(conn, data):
        print('writing')

    @staticmethod
    def open(conn):
        raise RuntimeError('Already open')

    @staticmethod
    def close(conn):
        conn.new_state(ClosedConnectionState)
```

다음은 이 클래스들을 사용하는 대화식 세션입니다.

```python
>>> c = Connection()
>>> c._state
"<class '__main__.ClosedConnectionState'>"
>>> c.read()
RuntimeError: Not open
>>> c.open()
>>> c._state
"<class '__main__.OpenConnectionState'>"
>>> c.read()
reading
>>> c.write('hello')
writing
>>> c.close()
>>> c._state
"<class '__main__.ClosedConnectionState'>"
```

#### Discussion

복잡한 조건문과 상태들이 얽혀 있는 큰 코드를 작성하는 것은 유지 관리 및 설명하기가 어렵습니다.
여기서의 Solution은 각 클래스들에서 개별 상태를 분리함으로써 이를 방지합니다.

약간 이상해 보일 수도 있지만 각 상태는 클래스의 *static* 메서드로 구현되었으며 각각의 인수는 `Connection`의 인스턴스를 첫 번째 인수로 취합니다.
이 디자인은 다른 상태 클래스 자체에 인스턴스 데이터를 저장하지 않기로 한 결정을 기반으로 합니다.
대신 모든 인스턴스 데이터가 `Connection` 인스턴스에 저장되어야 합니다.
일반 기본 클래스에서 상태를 그룹화하는 것은 대부분 코드를 구성하고 적절한 메서드를 구현하는 걸 보장하는 데에 도움이 됩니다.
가본 클래스메서드에서 발생하는 `NotImplementedError` 예외는 서브클래스가 필요한 메서드의 구현을 제공했는지 확인하기 위함입니다.
대안으로 [8.12장](#812-defining-an-interface-or-abstract-base-class)에서 설명한 대로 *abstract* 기본 클래스의 사용을 고려할 수도 있습니다.

대체 구현 기술로 인스턴스의 `__class__` 속성을 직접 조작하는 것과 관련이 있습니다.

```python
class Connection:
    def __init__(self):
        self.new_state(ClosedConnection)

    def new_state(self, newstate):
        self.__class__ = newstate

    def read(self):
        raise NotImplementedError()

    def write(self, data):
        raise NotImplementedError()

    def open(self):
        raise NotImplementedError()

    def close(self):
        raise NotImplementedError()

class ClosedConnection(Connection):
    def read(self):
        raise RuntimeError('Not open')

    def write(self, data):
        raise RuntimeError('Not open')

    def open(self):
        self.new_state(OpenConnection)

    def close(self):
        raise RuntimeError('Already closed')

class OpenConnection(Connection):
    def read(self):
        print('reading')

    def write(self, data):
        print('writing')

    def open(self):
        raise RuntimeError('Already open')

    def close(self):
        self.new_state(ClosedConnection)
```

이 구현의 주된 특징은 추가 레벨의 간접 참조를 제거한다는 것입니다.
`Connection`과 `ConnectionState` 클래스를 분리하는 대신, 두 클래스가 하나로 합쳐집니다. 상태가 바뀌면 인스턴스 상태의 타입도 다음과 같이 바뀝니다.

```python
>>> c = Connection()
>>> c
<__main__.ClosedConnection object at 0x1006718d0>
>>> c.read()
RuntimeError: Not open
>>> c.open()
>>> c
<__main__.OpenConnection object at 0x1006718d0>
>>> c.read()
reading
>>> c.close()
>>> c
<__main__.ClosedConnection object at 0x1006718d0>
```

순수 객체 지향을 추구하는 사람들은 단순히 인스턴스 `__class__` 특성을 변경한다는 아이디어에 불쾌할 수 있습니다.
하지만 기술적으로는 허용됩니다. 또한 더 이상의 추가적인 위임 단계를 포함하지 않기 때문에 `Connection`의 모든 메서드가 빨라 질 수 있습니다.

마지막으로 두 기법 모두 좀 더 복잡한 상태 머신을 구현하는 데 유용합니다.
특히 큰 `if-elif-else` 블록 특징의 코드에서 유용합니다.

```python
# Original implementation
class State:
    def __init__(self):
        self.state = 'A'

    def action(self, x):
        if state == 'A':
            # Action for A
            ...
            state = 'B'
        elif state == 'B':
            # Action for B
            ...
            state = 'C'
        elif state == 'C':
            # Action for C
            ...
            state = 'A'

# Alternative implementation
class State:
    def __init__(self):
        self.new_state(State_A)

    def new_state(self, state):
        self.__class__ = state

    def action(self, x):
        raise NotImplementedError()

class State_A(State):
    def action(self, x):
        # Action for A
        ...
        self.new_state(State_B)

class State_B(State):
    def action(self, x):
        # Action for B
        ...
        self.new_state(State_C)

class State_C(State):
    def action(self, x):
        # Action for C
        ...
        self.new_state(State_A)
```

이 장은 Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides의 *Design Patterns: Elements of Reusable Object-Oriented Software*(Addison-Wesley, 1995)에 있는 상태 디자인 패턴(state design pattern)을 기반으로 합니다.

## 8.20. Calling a Method on an Object Given the Name As a String

#### Problem

문자열로 저장된 객체에서 호출할 메서드의 이름이 있고 이 메서드를 실행하려고 합니다.

#### Solution

간단한 경우에 `getattr()`을 사용할 수 있습니다.

```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({!r:},{!r:})'.format(self.x, self.y)

    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
d = getattr(p, 'distance')(0, 0)    # Calls p.distance(0, 0)
```

대안으로는 `operator.methodcaller()`의 사용이 있습니다.

```python
import operator
operator.methodcaller('distance', 0, 0)(p)
```

`operator.methodcaller()`는 이름으로 메서드를 검색하고 동일한 인수를 계속해서 제공하려는 경우에 유용할 수 있습니다.
예를 들어 `points`의 전체 리스트를 정렬해야 하는 경우

```python
points = [
    Point(1, 2),
    Point(3, 0),
    Point(10, -3),
    Point(-5, -7),
    Point(-1, 8),
    Point(3, 2)
]

# Sort by distance from origin (0, 0)
points.sort(key=operator.methodcaller('distance', 0, 0))
```

#### Discussion

메서드 호출은 실제로 속성 조회와 함수 호출을 포함하는 두 단계로 나뉩니다.
그러므로 메서드를 호출하기 위해 다른 속성과 마찬가지로 `getattr()`를 사용하여 속성을 간단히 조회합니다.
메서드의 결과를 호출하려면 간단히 조회 결과를 함수로 처리합니다.
`operator.methodcaller()`는 호출 가능한 객체를 생성하지만 또한 메서드로 제공되는 인수를 수정합니다.
이제 할 일은 적절한 `self` 인수를 제공하는 것입니다.

```python
>>> p = Point(3, 4)
>>> d = operator.methodcaller('distance', 0, 0)
>>> d(p)
5.0
```

문자열에 포함된 이름을 사용하여 메서드를 호출하는 것은 케이스 문이나 다양한 *visitor* 패턴을 에뮬레이트하는 코드에서 다소 일반적입니다.
다음 장에 좀 더 심화된 예제가 있습니다.

## 8.21. Implementing the Visitor Pattern

#### Problem

서로 다른 종류의 객체로 구성된 복잡한 데이터 구조를 처리하거나 탐색하는 코드를 작성해야 합니다. 각 객체는 서로 다른 방식으로 처리해야 합니다.
예를 들어 트리 구조를 따라서 어떤 종류의 트리 노드를 거치는지 따라 다른 동작을 수행합니다.

#### Solution

이 장에서 다루는 문제는 많은 수의 서로 다른 객체로 구성된 데이터 구조를 만드는 프로그램에서 종종 발생합니다.
예를 들어 수학적 표현식을 나타내는 프로그램을 작성하려고 시도하는 것을 가정합니다.
그러기 위해 프로그램은 다음과 같은 많은 클래스를 사용할 수 있습니다.

```python
class Node:
    pass

class UnaryOperator(Node):
    def __init__(self, operand):
        self.operand = operand

class BinaryOperator(Node):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class Add(BinaryOperator):
    pass

class Sub(BinaryOperator):
    pass

class Mul(BinaryOperator):
    pass

class Div(BinaryOperator):
    pass

class Negate(UnaryOperator):
    pass

class Number(Node):
    def __init__(self, value):
        self.value = value
```

이러한 클래스는 다음과 같이 중첩된 데이터 구조를 구축하는 데 사용됩니다.

```python
# Representation of 1 + 2 * (3 - 4) / 5
t1 = Sub(Number(3), Number(4))
t2 = Mul(Number(2), t1)
t3 = Div(t2, Number(5))
t4 = Add(Number(1), t3)
```

문제는 이런 구조의 생성이 아니라 나중에 처리하는 코드를 작성하는 데 있습니다.
예를 들면 이 표현식에서 프로그램으로 여러가지를 하려고 할 것입니다(출력 생성, 인스트럭션 생성, 번역 수행 등).

범용 처리를 가능하게 하기 위한 일반적인 해결책은 다음과 유사하게 사용되는  소위 *visitor 패턴*이라 불리는 것을 구현하는 것입니다.

```python
class NodeVisitor:
    def visit(self, node):
        methname = 'visit_' + type(node).__name__
        meth = getattr(self, methname, None)
        if meth is None:
            meth = self.generic_visit
        return meth(node)

    def generic_visit(self, node):
        raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))
```

이 클래스를 사용하려면 프로그래머가 이를 상속받아 `visit_Name()` 형태의 다양한 메서드를 구현합니다. 여기서 `Name`은 노드 타입으로 대체됩니다.
예를 들어 표현식을 평가하려면 다음과 같이 작성할 수 있습니다.

```python
class Evaluator(NodeVisitor):
    def visit_Number(self, node):
        return node.value

    def visit_Add(self, node):
        return self.visit(node.left) + self.visit(node.right)

    def visit_Sub(self, node):
        return self.visit(node.left) - self.visit(node.right)

    def visit_Mul(self, node):
        return self.visit(node.left) * self.visit(node.right)

    def visit_Div(self.node):
        return self.visit(node.left) / self.visit(node.right)

    def visit_Negate(self, node):
        return -node.operand
```

다음은 이전에 생성된 표현식을 사용하여 이 클래스를 사용하는 방법의 예입니다.

```python
>>> e = Evaluator()
>>> e.visit(t4)
0.6
```

완전히 다른 예로 표현식을 간단한 스택 머신에서 연산으로 변환하는 클래스가 있습니다.

```python
class StackCode(NodeVisitor):
    def generate_code(self, node):
        self.instructions = []
        self.visit(node)
        return self.instructions

    def visit_Number(self, node):
        self.instructions.append(('PUSH', node.value))

    def binop(self, node, instruction):
        self.visit(node.left)
        self.visit(node.right)
        self.instructions.append((instruction,))

    def visit_Add(self, node):
        self.binop(node, 'ADD')

    def visit_Sub(self, node):
        self.binop(node, 'SUB')

    def visit_Mul(self, node):
        self.binop(node, 'MUL')

    def visit_Div(self, node):
        self.binop(node, 'DIV')

    def unaryop(self, node, instruction):
        self.visit(node.operand)
        self.instructions.append((instruction,))

    def visit_Negate(self, node):
        self.unaryop(node, 'NEG')
```

다음은 이 클래스 동작의 예입니다.

```python
>>> s = StackCode()
>>> s.generate_code(t4)
[('PUSH', 1), ('PUSH', 2), ('PUSH', 3), ('PUSH', 4), ('SUB',), ('MUL',), ('PUSH', 5), ('DIV',), ('ADD',)]
```

#### Discussion

이 장에는 두 가지 핵심 아이디어가 있습니다. 첫 번째는 복잡한 데이터 구조를 조작하는 코드가 데이터 구조 자체와 분리되는 디자인 전략입니다.
즉 이 장에는 다양한 `Node` 클래스가 데이터를 처리하는 어떤 구현도 제공하지 않습니다.
대신 모든 데이터 조작은 별도의 `NodeVisitor` 클래스로 나뉘어진 특정 구현에 의해 수행됩니다.
이 분리는 코드를 매우 범용적으로 만들어 줍니다.

이 장의 두 번째 주요 아이디어는 *visitor* 클래스 자체의 구현입니다.
*visitor*에서 노드 타입과 같은 어떤 값을 기반으로 다른 핸들링 메서드를 디스패치하려고 합니다.
간단한 구현으로는 다음과 같이 거대한 `if`문을 작성하게 되는 경향이 있습니다.

```python
class NodeVisitor:
    def visit(self, node):
        nodetype = type(node).__name__
        if nodetype == 'Number':
            return self.visit_Number(node)
        elif nodetype == 'Add':
            return self.visit_Add(node)
        elif nodetype == 'Sub':
            return self.visit_Sub(node)
        ...
```

하지만 명백하게 원하는 접근 법이 아닐 것입니다.
엄청 장황할 뿐더러 천천히 실행되므로 처리되는 노드의 종류가 추가되거나 변경되면 유지 관리가 어렵습니다.
대신 메서드의 이름을 만들고 `getattr()` 함수로 가져올 때 약간의 트릭을 사용하는 것이 훨씬 낫습니다.
Solution의 `generic_visit()` 메서드는 매치되는 핸들러 메서드가 없으면 뺄 수 있습니다.
이 장에서 예기치 않은 노드 타입이 발생했다는 것을 프로그래머에게 경고하는 예외를 일으킵니다.

각 *visitor* 클래스 내에 `visit()` 메서드에 대해 재귀 호출에 의한 계산을 수행하는 것이 일반적입니다.

```python
class Evaluator(NodeVisitor):
    ...
    def visit_Add(self, node):
        return self.visit(node.left) + self.visit(node.right)
```

이 재귀는 *visitor* 클래스가 전체 데이터 구조를 탐색하도록 합니다.
본질적으로 `Number` 예와 같이 터미널 노드에 도달할 때까지 `visit()`을 계속 호출합니다.
재귀 및 기타 작업의 정확한 순서는 애플리케이션에 전적으로 달려 있습니다.

메서드를 디스패치하는 이 특별한 기술은 다른 언어의 `switch` 또는 `case` 문을 에뮬레이션하는 일반적인 방법이기도 합니다.
예를 들어 HTTP 프레임워크를 작성할 경우 비슷한 종류의 디스패치를 하는 클래스가 있을 수 있습니다.

```python
class HTTPHandler:
    def handle(self, request):
        methname = 'do_' + request.request_method
        getattr(self, methname)(request)

    def do_GET(self, request):
        ...

    def do_POST(self, request):
        ...

    def do_HEAD(self, request):
        ...
```

*visitor* 패턴의 약점 중 하나는 재귀에 대한 의존도가 심하다는 것입니다.
깊은 중첩 구조에 적용하려고 한다면 Python의 재귀 깊이 제한에 도달할 가능성이 있습니다(`sys.getrecursionlimit()` 참조). 이 문제를 방지하려면 데이터 구조에서 특정 선택을 할 수 있습니다.
예를 들어 `linked list` 대신 일반 Python `list`를 사용하거나 각 노드에서 더 많은 데이터를 집계하여 데이터를 줄일 수 있습니다.

또한 [8.22장](#822-implementing-the-visitor-pattern-without-recursion)에서의 Discussion처럼 *generator* 또는 *iterator*를 사용하여 비 재귀 탐색 알고리즘을 시도할 수도 있습니다.

*visitor* 패턴의 사용은 파싱 및 컴파일과 관련된 프로그램에서 매우 일반적입니다.
주목할만한 하나의 구현은 Python 자체의 `ast` 모듈에서 찾아볼 수 있습니다.
트리 구조의 탐색을 허용하는 것 외에도 트리 구조가 탐색이 될 때 데이터 구조를 재 작성하거나 변형할 수 있는 다양한 것들을(노드 추가 또는 제거) 제공합니다.
`ast` 소스를 통해 자세한 것들을 볼 수 있습니다.
[9.24장]()에서 `ast` 모듈을 사용하여 Python 소스 코드를 처리하는 예제를 볼 수 있습니다.

## 8.22. Implementing the Visitor Pattern Without Recursion

#### Problem

*visitor* 패턴을 사용하여 깊게 중첩된 트리 구조를 통해 탐색하는 코드를 작성하고 있지만 재귀 한계를 초과하게 됩니다.
재귀를 제거하려고 하지만 *visitor* 패턴의 프로그래밍 스타일은 유지하려고 합니다.

#### Solution

*generator*를 영리하게 사용하면 트리 탐색 또는 검색과 관련된 알고리즘에서 재귀를 제거하는데 사용할 수 있습니다.
[8.21장](#821-implementing-the-visitor-pattern)에서 `visitor` 클래스가 제공되었습니다.
다음은 *stack*과 *generator*를 사용하여 완전히 다른 방법의 계산을 이끌어내는 클래스 구현의 대안입니다.

```python
import types

class Node:
    pass

class NodeVisitor:
    def visit(self, node):
        stack = [node]
        last_result = None
        while stack:
            try:
                last = stack[-1]
                if isinstance(last, types.GeneratorType):
                    stack.append(last.send(last_result))
                    last_result = None
                elif isinstance(last, Node):
                    stack.append(self._visit(stack.pop()))
                else:
                    last_result = stack.pop()
            except StopIteration:
                stack.pop()
        return last_result

    def _visit(self, node):
        methname = 'visit_' + type(node).__name__
        meth = getattr(self, methname, None)
        if meth is None:
            meth = self.generic_visit
        return meth(node)

    def generic_visit(self, node):
        raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))
```

이 클래스를 사용할 경우 재귀를 사용한 기존 코드와도 작동함을 알 수 있습니다.
사실 이전 장의 *visitor* 구현을 위한 대체로 사용할 수 있습니다.
예를 들어 다음 트리 표현과 관련된 다음 코드를 고려하면

```python
class UnaryOperator(Node):
    def __init__(self, operand):
        self.operand = operand

class BinaryOperator(Node):
    def __init__(self, left, right):
        self.left = left
        self.right = right

class Add(BinaryOperator):
    pass

class Sub(BinaryOperator):
    pass

class Mul(BinaryOperator):
    pass

class Div(BinaryOperator):
    pass

class Negate(UnaryOperator):
    pass

class Number(Node):
    def __init__(self, value):
        self.value = value

# A sample visitor class that evaluates expressions
class Evaluator(NodeVisitor):
    def visit_Number(self, node):
        return node.value

    def visit_Add(self, node):
        return self.visit(node.left) + self.visit(node.right)

    def visit_Sub(self, node):
        return self.visit(node.left) - self.visit(node.right)

    def visit_Mul(self, node):
        return self.visit(node.left) * self.visit(node.right)

    def visit_Div(self, node):
        return self.visit(node.left) + self.right(node.right)

    def visit_Negate(self, node):
        return -self.visit(node.operand)

if __name__ == '__main__':
    # 1 + 2 * (3 - 4) / 5
    t1 = Sub(Number(3), Number(4))
    t2 = Mul(Number(2), t1)
    t3 = Div(t2, Number(5))
    t4 = Add(Number(1), t3)

    # Evaluate it
    e = Evaluator()
    print(e.visit(t4))      # Outputs 0.6
```

앞의 코드는 간단한 표현식에 동작합니다. 하지만 `Evaluator`의 구현이 재귀를 너무 중첩시키는 부분에서 사용한다면 충돌할 것입니다. 예를 들면

```python
>>> a = Number(0)
>>> for n in range(1, 100000):
...     a = Add(a, Number(n))
...
>>> e = Evaluator()
>>> e.visit(a)
RuntimeError: maximum recursion depth exceeded
```

이제 `Evaluator` 클래스를 다음과 같이 약간 변경합니다.

```python
class Evalutator(NodeVisitor):
    def visit_Number(self, node):
        return node.value

    def visit_Add(self, node):
        yield (yield node.left) + (yield node.right)

    def visit_Sub(self, node):
        yield (yield node.left) - (yield node.right)

    def visit_Mul(self, node):
        yield (yield node.left) * (yield node.right)

    def visit_Div(self, node):
        yield (yield node.left) / (yield node.right)

    def visit_Negate(self, node):
        yield -(yield node.operand)
```

동일한 재귀함수로 실험해보면 갑자기 작동하는 것을 알 수 있습니다.

```python
>>> a = Number(0)
>>> for n in range(1, 100000):
...     a = Add(a, Number(n))
...
>>> e = Evaluator()
>>> e.visit(a)
4999950000
```

커스텀 처리를 다른 모든 메서드에 추가하려고 하는 경우에도 여전히 동작합니다.

```python
class Evaluator(NodeVisitor):
    ...
    def visit_Add(self, node):
        print('Add:', node)
        lhs = yield node.left
        print('left=', lhs)
        rhs = yield node.right
        print('right=', rhs)
        yield lhs + rhs
    ...
```

다음은 샘플 출력입니다.

```python
>>> e = Evaluator()
>>> e.visit(t4)
Add: <__main__.Add object at 0x1006a8d90>
left= 1
right= -0.4
0.6
```

#### Discussion

이 장은 *generator*와 *coroutine*이 *control flow*와 관련된 재미있는 트릭을 수행할 수 있는 방법을 잘 보여줍니다.
이 장을 이해하려면 몇 가지 핵심적인 통찰력을 필요로 합니다.

첫 번째로, 트리 탐색과 관련된 문제에서 재귀를 피하기 위한 일반적인 구현 전략은 스택이나 큐와 관련된 알고리즘을 작성하는 것입니다.
예를 들어 첫 번째 깊이 탐색은 노드가 처음 발견되었을 때 노드를 스택으로 `push`한 다음 처리가 끝나고 `pop` 하여 완전히 구현할 수 있습니다.
Solution의 `visit()` 메서드의 핵심은 이 아이디어를 바탕으로 합니다.
알고리즘은 처음 노드를 `stack` 리스트로 `push`하여 시작하며 스택이 비게 될 때까지 실행됩니다.
실행되는 동안 스택은 기본 트리 구조의 깊이에 따라 커질 것입니다.

두 번째는 *generator*에서 `yield`문의 동작을 고려하는 것입니다.
`yield`문을 만날 때 *generator*의 동작은 값을 보내고 유지하는 것입니다.
이 장은 재귀를 대체함으로써 이를 사용합니다. 예를 들어 다음과 같은 재귀 표현식을 작성하는 대신에

```python
value = self.visit(node.left)
```

다음으로 그것을 대체합니다.

```python
value = yield node.left
```

위에서 문제의 노드(`node.left`)를 다시 `visit()` 메서드로 보냅니다.
그 후 `visit()` 메서드는 적절한 `visit_Name()` 메서드를 실행합니다.
어떤 의미에서 이것은 재귀와 거의 반대입니다.
즉 다음 알고리즘으로 이동하는 `visit()`을 반복적으로 호출하는 대신 `yield`문을
사용하여 진행 중인 계산에서 일시적으로 복귀합니다.
그러므로 `yield`는 추후 노드가 더 진행되기 전에 먼저 처리되어야 한다는 것을 알고리즘에 알리는 필수적인 신호입니다.

이 장의 마지막 부분은 결과 전파에 관한 것입니다. *generator* 함수가 사용될 때 더 이상 `return`문을 사용하여 값을 내보낼 수 없습니다(그렇게 한다면 `SyntaxError` 예외가 발생합니다). 그러므로 `yield` 문은 이 경우를 다루는 두 가지 의무가 있습니다.
이 장에서 `yield`문에 의해 생성된 값이 노드 타입이 아닌 경우 계산의 다음 단계로 전파되는 값으로 간주됩니다.
이는 코드의 `last_return` 변수의 목적입니다. 전형적으로 이는 `visit` 메서드에 의해 산출된 마지막 값을 보유하게 됩니다.
그런 다음 이 값은 이전에 실행 중인 메서드로 보내지며 `yield`문의 반환 값으로 표시됩니다. 예를 들어 다음 코드에서

```python
value = yield node.left
```

`value` 변수는 `last_return`의 값을 얻습니다. 이는 `node.left`로 호출된 *visitor* 메서드에 의해 리턴된 결과입니다.

이 장의 이런 모든 측면은 다음과 같은 코드에서 찾아 볼 수 있습니다.

```python
try:
    last = stack[-1]
    if isinstance(last, types.GeneratorType):
        stack.append(last.send(last_result))
        last_result = None
    elif isinstance(last, Node):
        stack.append(self._visit(stack.pop()))
    else:
        last_result = stack.pop()
except StopIteration:
    stack.pop()
```

이 코드는 단순히 스택의 맨 위를 보고 다음에 수행할 작업을 결정하는 방식으로 동작합니다.
만약 *generator*라면 `send()` 메서드가 마지막 결과(있는 경우)와 함께 호출되고 결과가 추가 처리를 위해 스택에 추가됩니다.
`send()`로 반환된 값은 `yield`문으로 주어진 값과 같습니다. 그러므로 `yield node.left`와 같은 문에서 `Node` 인스턴스인 `node.left`는 `send()`에 의해 반환되고 스택의 맨 위에 배치됩니다.

만약 스택의 맨 위가 `Node` 인스턴스라면 해당 노드에 대한 적절한 `visit` 메서드를 호출한 결과로 대체합니다. 여기서 기본 재귀가 제거됩니다.
여러 `visit` 메서드가 직접 재귀적으로 `visit()`을 호출하는 대신 이곳에서 일어나게 됩니다. 메서드가 `yield`를 사용하는 한 모두 동작합니다.

마지막으로 스택의 맨 위가 그 밖의 것일 경우 어떤 종류의 반환 값이라고 간주합니다.
그냥 스택에서 `pop`된 후 `last_result`에 배치됩니다.
만약 스택의 다음 항목이 *generator*이면 `yield`의 반환 값으로 보내집니다.
마지막으로 `visit()`의 리턴 값도 역시 `last_result`로 설정된다는 점을 주목하시기 바랍니다.
이는 전통적인 재귀 구현으로 이 장에서 동작하게 됩니다. 만일 *generator*가 사용되지 않았다면 이 값은 코드에 사용된 모든 `return` 문에 주어진 값을 유지하게 될 것입니다.

이 장의 위험할 수 있는 요소는 `Node`를 넘겨주는 것과 `Node`가 아닌 값을 구별하는 것입니다. 이 구현에서 모든 `Node` 인스턴스는 자동으로 탐색됩니다.
이는 전달된 리턴 값으로 `Node`를 사용할 수 없음을 의미합니다.
실제로 이는 중요하지 않을 지도 모릅니다. 하지만 중요하다면 알고리즘을 약간 수정해야 할 수도 있습니다. 예를 들어 *mix*에 다른 클래스를 다음과 같이 도입합니다.

```python
class Visit:
    def __init__(self, node):
        self.node = node

class NodeVisitor:
    def visit(self, node):
        stack = [ Visit(node) ]
        last_result = None
        while stack:
            try:
                last = stack[-1]
                if instance(last, types.GeneratorType):
                    stack.append(last.send(last_result))
                    last_result = None
                elif isinstance(last, Visit):
                    stack.append(self._visit(stack.pop().node))
                else:
                    last_result = stack.pop()
            except StopIteration:
                stack.pop()
        return last_result

    def _visit(self, node):
        methname = 'visit_' + type(node).__name__
        meth = getattr(self, methname, None)
        if meth is None:
            meth = self.generic_visit
        return meth(node)
    
    def generic_visit(self, node):
        raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))
```

이 구현으로 *visitor* 메서드가 다음과 같이 나타납니다.

```python
class Evaluator(NodeVisitor):
    ...
    def visit_Add(self, node):
        yield (yield Visit(node.left)) + (yield Visit(node.right))

    def visit_Sub(self, node):
        yield (yield Visit(node.left)) - (yield Visit(node.right))
    ...
```

이 장을 봤을 때 `yield`를 포함하지 않는 Solution을 조사할 수도 있을 것입니다.
하지만 그렇게 했을 때 여기에 제시된 것과 동일한 여러가지 문제를 처리해야 하는 코드로 이어질 것입니다.
예를 들어 재귀를 제거하려면 스택을 유지해야 할 것입니다. 또한 탐색을 관리하고 다양한 *visitor* 관련 로직을 호출하기 위한 체계가 필요하게 될 것입니다.
*generator*가 없으면 이 코드는 스택 조작, 콜백 함수 및 다른 구조를 복잡하게 혼합한 결과가 될 것입니다.
솔직히 `yield`를 사용하는 주된 이점은 재귀적 구현과 거의 비슷하게 보이는 우아한 스타일로 비 재귀적 코드를 작성할 수 있다는 점입니다.

## 8.23. Managing Memory in Cyclic Data Structures

#### Problem

프로그램이 순환(트리, 그래프, *observer* 패턴 등)이 있는 데이터 구조를 생성하지만 메모리 관리에 문제가 있다는 것을 알게되었습니다.

#### Solution

순환 데이터 구조의 간단한 예는 부모가 자식을 가리치고 자식이 부모를 가리키는 트리 구조입니다.
이런 코드에서는 `weakref` 라이브러리를 사용하여 링크 중 하나를 약한 참조로 만드는 것을 고려해야 합니다.

```python
import weakref

class Node:
    def __init__(self, value):
        self.value = value
        self._parent = None
        self.children = []

    def __repr__(self):
        return 'Node({!r:})'.format(self.value)

    # property that manages the parent as a weak-reference
    @property
    def parent(self):
        return self._parent if self._parent is None else self._parent()

    @parent.setter
    def parent(self, node):
        self._parent = weakref.ref(node)

    def add_child(self, child):
        self.children.append(child)
        child.parent = self
```

이 구현을 통해 부모 객체가 조용히 제거됩니다.

```python
>>> root = Node('parent')
>>> c1 = Node('child')
>>> root.add_child(c1)
>>> print(c1.parent)
Node('parent')
>>> del root
>>> print(c1.parent)
None
```

#### Discussion

순환 데이터 구조는 종종 일반적인 가비지 컬렉션 규칙이 적용되지 않기 때문에 신중하게 조사해야하는 Python의 다소 까다로운 부분입니다.
예를 들면

```python
# Class just to illustrate when deletion occurs
class Data:
    def __del__(self):
        print('Data.__del__')

# Node class involving a cycle
class Node:
    def __init__(self):
        self.data = Data()
        self.parent = None
        self.children = []

    def add_child(self, child):
        self.children.append(child)
        child.parent = self
```

이제 이 코드를 사용하여 가비지 컬렉션에 대한 미묘한 문제를 확인하기 위한 실험을 시도합니다.

```python
>>> a = Data()
>>> del a       # Immediately deleted
Data.__del__
>>> a = Node()
>>> del a       # Immediately deleted
Data.__del__
>>> a = Node()
>>> a.add_child(Node())
>>> del a       # Not deleted (no message)
```

보시다시피 순환과 관련된 마지막 케이스를 제외하고 객체가 즉시 삭제됩니다.
이 이유는 가비지 컬렉션이 간단한 *reference counting*을 기반으로 하기 때문입니다.
객체의 *reference count*가 0에 도달하면 즉시 삭제됩니다. 하지만 순환 데이터 구조에서는 이런 일이 절대 일어나지 않습니다. 그러므로 마지막 예제에서 부모와 자식 노드가 서로를 참조하며 *reference count*가 0이 아닌 상태로 유지됩니다.

순환을 처리하기 위해 주기적으로 실행되는 별도의 가비지 컬렉터가 있습니다.
하지만 일반적으로 언제 실행 되는지 알 수 없습니다. 결과적으로 순환 데이터 구조가 언제 수집되는 지 알 수 없게 됩니다. 필요할 경우 강제로 가비지 컬렉션을 실행할 수 있지만 그렇게 하는 것은 다소 복잡합니다.

```python
>>> import gc
>>> gc.collect()        # Force collection
Data.__del__
Data.__del__
```

순환과 관련된 객체가 자체적으로 `__del__()` 메서드를 정의하는 경우 더 심각한 문제가 발생합니다. 예를 들어 다음과 같은 코드가 있다고 가정합니다.

```python
# Class just to illustrate when deletion occurs
class Data:
    def __del__(self):
        print('Data.__del__')

# Node class involving a cycle
class Node:
    def __init__(self):
        self.data = Data()
        self.parent = None
        self.children = []

    # NEVER DEFINE LIKE THIS
    # Only here to illustrate pathological behavior
    def __del__(self):
        del self.data
        del.parent
        del.children

    def add_child(self, child):
        self.children.append(child)
        child.parent = self
```

이 경우 데이터 구조는 절대 가비지 컬렉션되지 않으므로 프로그램의 메모리 누수가 될 것입니다! 이를 시도하려면 `Data.__del__` 메시지가 가비지 컬렉션을 강제로 했음에도 절대 나타나지 않음을 확인할 수 있습니다.

```python
>>> a = Node()
>>> a.add_child(Node())
>>> del a           # No message (not collected)
>>> import gc
>>> gc.collect()    # No message (not collected)
```

*weak* 참조는 순환 참조를 제거하여 이 문제를 해결합니다. 본질적으로 *weak* 참조는 *reference count*를 증가시키지 않는 객체의 포인터입니다.
`weakref` 라이브러리를 사용하여 *weak* 참조를 생성합니다.

```python
>>> import weakref
>>> a = Node()
>>> a_ref = weakref.ref(a)
>>> a_ref
<weakref at 0x100581f70; to 'Node' at 0x1005c5410>
```

*weak* 참조를 역으로 참조하려면 함수처럼 호출합니다. 호출된 객체가 여전히 존재할 경우 그 객체를 반환합니다. 그렇지 않으면 `None`이 반환됩니다.
원본 객체의 *reference count*가 증가하지 않았으므로 이를 정상적으로 삭제할 수 있습니다.

```python
>>> print(a_ref())
<__main__.Node object at 0x1005c5410>
>>> del a
Data.__del__
>>> print(a_ref())
None
```

*weak* 참조 사용으로 Solution에서 보인 것 처럼 더 이상 참조의 순환이 없고 노드가 더이상 사용되지 않으면 가비지 컬렉션이 즉시 발생함을 알 수 있습니다.
[8.25장](#825-creating-cached-instances)에 *weak* 참조와 관련된 또 다른 예제를 참고하시기 바랍니다.

## 8.24. Making Classes Support Comparison Operations

#### Problem

표준 비교 연산자(`>=`, `!=`, `<=`, 등)를 사용하여 클래스의 인스턴스를 비교할 수 있게 하려고 합니다. 하지만 특별한 메서드 작성이 없게 하려고 합니다.

#### Solution

Python 클래스는 각 비교 연산자에 특별한 메서드를 구현하여 비교를 제공할 수 있습니다.
예를 들어 `>=` 연산자를 제공하려면 `__ge__()` 메서드를 클래스에 정의합니다.
단일 메서드를 정의하는 일반적으로 문제가 되지 않지만 모든 가능한 비교 연산자의 구현을 만드는 것은 쉽게 지루해집니다.

`functools.total_ordering` *decorator*는 이 프로세스에 간단히 사용될 수 있습니다.
이를 사용하려면 클래스를 *decorate*하고 `__eq__()` 와 또다른 하나의 비교 메서드(`__lt__`, `__le__`, `__gt__`, 또는 `__ge__`)를 정의합니다.
그리고 *decorator*는 다른 비교 메서드를 채우게 됩니다.

예를 들어 집을 만들고 거기에 방을 추가하며 집의 크기를 기반으로 비교를 수행해 봅니다.

```python
from functools import total_ordering

class Room:
    def __init__(self, name, length, width):
        self.name = name
        self.length = length
        self.width = width
        self.square_feet = self.length * self.width

@total_ordering
class House:
    def __init__(self, name, style):
        self.name = name
        self.style = style
        self.rooms = list()

    @property
    def living_space_footage(self):
        return sum(r.square_feet for r in self.rooms)

    def add_room(self, room):
        self.rooms.append(room)

    def __str__(self):
        return '{}: {} square foot {}'.format(self.name, self.living_space_footage, self.style)

    def __eq__(self, other):
        return self.living_space_footage == other.living_space_footage

    def __lt__(self, other):
        return self.living_space_footage < other.living_space_footage
```

여기 `House` 클래스는 `@total_ordering`으로 *decorate* 되었습니다. `__eq__()`와 `__lt__()` 정의는 방의 총 면적을 기반으로 집을 비교하게 됩니다.
이 최소한의 정의는 다른 모든 비교 연산을 수행하는 데 필요한 모든 것입니다.

```python
# Build a few houses, and add rooms to them
h1 = House('h1', 'Cape')
h1.add_room(Room('Master Bedroom', 14, 21))
h1.add_room(Room('Living Room' 18, 20))
h1.add_room(Room('Kitchen', 12, 16))
h1.add_room(Room('Office', 12, 12))

h2 = House('h2', 'Ranch')
h2.add_room(Room('Master Bedroom', 14, 21))
h2.add_room(Room('Living Room', 18, 20))
h2.add_room(Room('Kitchen', 12, 16))

h3 = House('h3', 'Split')
h3.add_room(Room('Master Bedroom', 14, 21))
h3.add_room(Room('Living Room', 18, 20))
h3.add_room(Room('Office', 12, 16))
h3.add_room(Room('Kitchen', 15, 17))
houses = [h1, h2, h3]

print('Is h1 bigger than h2?', h1 > h2)     # True
print('Is h2 smaller than h3?', h2 < h3)    # True
print('Is h2 greater than or equal to h1?', h2 >= h1)    # False
print('Which one is biggest?', max(houses)) # h3: 1101 Split
print('Which is smallest?', min(houses))    # h2: 846 Ranch
```

#### Discussion

클래스에 모든 기본 비교 연산자를 지원하는 코드를 작성한 경우 `total_ordering`은 신기하게 보이진 않을 것입니다.
즉 문자 그대로 필요한 모든 다른 비교 연산자로의 매핑을 정의하게 됩니다.
이는 클래스에 다음과 같은 메서드를 채우기만 하면 됩니다.

```python
class House:
    def __eq__(self, other):
        ...
    def __lt__(self, other):
        ...
    # Methods created by @total_ordering
    __le__ = lambda self, other: self < other or self == other
    __gt__ = lambda self, other: not (self < other or self == other)
    __ge__ = lambda self, other: not (self < other)
    __ne__ = lambda self, other: not self == other
```

물론 이 메서드들을 직접 작성하는 것은 어렵지 않지만 `@total_ordering`으로 간단히 할 수 있습니다.

## 8.25. Creating Cached Instances

#### Problem

클래스의 인스턴스를 생성할 때 동일한 인수(있다면)로 생성된 이전 인스턴스로 캐시된 참조로 반환하려고 합니다.

#### Solution

이 장에서 다루는 문제는 일련의 입력 인수에 대해 생성된 하나 뿐인 인스턴스가 있는지 확인하려는 경우에 때때로 발생합니다.
`logging` 모듈과 같은 동작의 라이브러리를 포함하는 실용적인 예제는 단일 로거 인스턴스를 주어진 이름과 연관시키길 원하는 것입니다. 예를 들면

```python
>>> import logging
>>> a = logging.getLogger('foo')
>>> b = logging.getLogger('bar')
>>> a is b
False
>>> c = logging.getLogger('foo')
>>> a is c
True
```

이런 동작을 구현하려면 클래스 자체와는 별도의 팩토리 함수를 사용해야 합니다.

```python
# The class in question
class Spam:
    def __init__(self, name):
        self.name = name

# Caching support
import weakref

_spam_cache = weakref.WeakValueDictionary()

def get_spam(name):
    if name not in _spam_cache:
        s = Spam(name)
        _spam_cache[name] = s
    else:
        s = _spam_cache[name]
    return s
```

이 구현을 사용하면 이전과 같은 방식으로 동작함을 알 수 있습니다.

```python
>>> a = get_spam('foo')
>>> b = get_spam('bar')
>>> a is b
False
>>> c = get_spam('foo')
>>> a is c
True
```

#### Discussion

특별한 팩토리 함수를 작성하는 것은 종종 인스턴스 생성의 일반적인 규칙을 변경하기 위한 간단한 접근입니다.
이 시점에서 일어나는 질문은 좀 더 우아한 접근 방법을 취할 수 있는지의 여부입니다.

예를 들어 다음과 같은 `__new__()` 메서드를 재정의하는 방법을 고려해 봅니다.

```python
# Note: This code doesn't quite work
import weakref

class Spam:
    _spam_cache = weakref.WeakValueDictionary()
    def __new__(cls, name):
        if name in cls._spam_cache:
            return cls._spam_cache[name]
        else:
            self = super().__new__(cls)
            cls._spam_cache[name] = self
            return self

    def __init__(self, name):
        print('Initializing Spam')
        self.name = name
```

언뜻 보면 코드가 동작하는 것처럼 보입니다. 하지만 주된 문제는 인스턴스가 캐시 여부에 상관없이 `__init__()` 메서드가 항상 호출된다는 것입니다.

```python
>>> s = Spam('Dave')
Initializing Spam
>>> t = Spam('Dave')
Initializing Spam
>>> s is t
True
```

이는 원하던 동작이 아닐 것입니다. 그래서 다시 초기화하는 문제 없이 캐싱의 문제를 해결하려면 약간 다른 접근을 취해야 합니다.

이 장에서 *weak* 참조를 사용하는 것은 [8.23장](#823-managing-memory-in-cyclic-data-structures)에서 설명한 가비지 컬렉션과 관련된 중요한 목적을 제공합니다.
인스턴스의 캐시를 유지하는 경우 실제로 프로그램에서 사용되는 경우에 한해서 항목을 캐시에 보관하기를 원할 때가 많습니다.
`WeakValueDictionary` 인스턴스는 다른 곳에 존재하는 한 참조된 항목만 보유합니다. 그렇지 않으면 인스턴스가 더 이상 사용되지 않을 때 `dictionary` 키가 사라집니다.

```python
>>> a = get_spam('foo')
>>> b = get_spam('bar')
>>> c = get_spam('foo')
>>> list(_spam_cache)
['foo', 'bar']
>>> del a
>>> del c
>>> list(_spam_cache)
['bar']
>>> del b
>>> list(_spam_cache)
[]
```

많은 프로그램에서 이 장에서 보인 코드가 종종 충분한 경우가 있습니다.
하지만 고려할 수 있는 더 많은 고급 구현 기술이 있습니다.

한가지 이 장의 우려는 전역 변수에 대한 의존성과 원래 클래스 정의와 분리된 팩토리 함수일 수 있습니다.
이를 정리하는 한가지 방법은 캐싱 코드를 별도의 매니저 클래스에 넣고 다음과 같이 묶는 것입니다.

```python
import weakref

class CachedSpamManager:
    def __init__(self):
        self._cache = weakref.WeakValueDictionary()

    def get_spam(self, name):
        if name not in self._cache:
            s = Spam(name)
            self._cache[name] = s
        else:
            s = self._cache[name]
        return s

    def clear(self):
        self._cache.clear()

class Spam:
    manager = CachedSpamManager()

    def __init__(self, name):
        self.name = name

    def get_spam(name):
        return Spam.manager.get_spam(name)
```

이 접근법의 한가지 특징은 잠재적인 유연성의 정도를 높일 수 있다는 것입니다.
예를 들어 다른 종류의 관리 체계가 구현될 수 있으며(별도의 클래스로) `Spam` 클래스에 기본 캐싱 구현을 대신할 수 있습니다.
다른 코드(`get_spam`)가 동작하는 어떠한 변경도 없어야 합니다.

또 다른 고려 사항은 클래스 정의를 사용자에게 노출 할 것인지의 여부입니다.
아무 것도 하지 않으면 사용자는 캐싱 매커니즘을 거치지 않고 쉽게 인스턴스를 만들 수 있습니다.

```python
>>> a = Spam('foo')
>>> b = Spam('foo')
>>> a is b
False
```

이를 방지하는 것이 중요하다면, 이를 피하기 위해 특정 조치를 취할 수 있습니다.
예를 들어 `_Spam` 같이 클래스 이름을 밑줄로 시작한다면 최소한 사용자가 직접 액세스해서는 안된다는 단서를 줄 수 있습니다.

또는 `Spam` 인스턴스를 직접 인스턴스화해서는 안된다는 강력한 힌트를 사용자에게 제공하려는 경우 `__init__()`으로 예외를 발생시키고 *classmethod*를 사용하여 다음과 같은 대체 *constructor*를 만들 수 있습니다.

```python
class Spam:
    def __init__(self, *args, **kwargs):
        raise RuntimeError("Can't instantiate directly")

    # Alternate constructor
    @classmethod
    def _new(cls, name):
        self = cls.__new__(cls)
        self.name = name
```

이를 사용하려면 캐싱 코드를 수정하여 일반적인 `Spam()` 호출 대신 `Spam._new()`를 사용하여 인스턴스를 만듭니다.

```python
import weakref

class CachedSpamManager:
    def __init__(self):
        self._cache = weakref.WeakValueDictionary()
    
    def get_spam(self, name):
        if name not in self._cache:
            s = Spam._new(name)     # Modified creation
            self._cache[name] = s
        else:
            s = self._cache[name]
        return s
```

`Spam` 클래스의 가시성을 숨기기 위해 취할 수 있는 더 극단적인 방법이 있지만 문제를 과장하지 않는 것이 가장 좋습니다.
이름에 밑줄을 사용하거나 *classmethod* *constructor*를 정의하면 일반적으로 프로그래머가 힌트를 얻을 수 있습니다.

캐싱 및 기타 패턴은 종종 *metaclass*를 사용하여 좀 더 우아한 방법으로 해결 될 수 있습니다. [9.13장]()을 참고하시기 바랍니다.