rem
rem	Script:		clufac_calc.sql
rem	Author:		Jonathan Lewis
rem	Dated:		Sept 2003
rem	Purpose:	Demonstration script for Cost Based Oracle'.
rem
rem	Versions tested 
rem		10.1.0.2
rem		 9.2.0.4
rem		 8.1.7.4
rem
rem	Notes:
rem	This code should only be run after you have created and populated
rem	the table defined in free_lists.sql
rem
rem	If you trace a call to dbms_stats in Oracle 9, you will find SQL like
rem	the code in this script.  (The exact SQL will depend on the number of
rem	columns in the index, whether the index is actually an IOT or a secondary
rem	index on an IOT and so on).
rem
rem	Not the column aliased to CLF, generated by the function sys_op_countchg.
rem	COUNTing the CHanGe in table block addresses is exactly what the CLustering
rem	Factor is about - and this is the column that generates the number you get.
rem
rem	But what is the second parameter to the sys_op_countchg() function ?
rem	Could it be possibly be a hint about the number of steps that Oracle
rem	can take along the index before coming back to a block and treating it
rem	as a 'no change' visit ?  In effect, a balance to the effect of setting
rem	freelists greater than 1.
rem
rem	If you run this SQL, changing the value of that parameter each time,
rem	then you get the following results on my table with freelists = 5
rem
rem		Parameter	CLF
rem		1		26,000
rem		2		26,000
rem		3		26,000
rem		4		25,948
rem		5		   746	-- which is a "reasonable" value for this index.
rem	
rem	It really looks as if you could use this SQL to get a 'reasonable' clustering
rem	factor for an index by setting the parameter to match the freelsts on the table.
rem	(when freelist groups = 1)
rem

start setenv

spool clufac_calc


prompt
prompt		Second parameter fixed at 1
prompt

select /*+ 
		cursor_sharing_exact 
		dynamic_sampling(0) 
		no_monitoring 
		no_expand 
		index(t,"T1_I1") 
		noparallel_index(t,"T1_I1") 
	*/ 
--
--	NRW	Number of rows
--	NLB	Number of leaf blocks
--	NDK	Number of distinct keys - the sys_op_descend() is probably used
--		for multi-column indexes to introduce a special character between
--		the column values, to avoid seeing things like ('aa','bb') as 
--		identical to ('aab','b').
--	CLF	Clustering factor
--
--	count(*) as nrw,
--	count(distinct sys_op_lbid(49721,'L',t.rowid)) as nlb,
--	count(distinct hextoraw(sys_op_descend("DATE_ORD")||sys_op_descend("SEQ_ORD"))) as ndk,
	sys_op_countchg(substrb(t.rowid,1,15),1) as clf 
from 
	"TEST_USER"."T1"  t 
where 
	"DATE_ORD" is not null 
or	"SEQ_ORD" is not null
;


prompt
prompt		Second parameter fixed at 5
prompt

select /*+ 
		cursor_sharing_exact 
		dynamic_sampling(0) 
		no_monitoring 
		no_expand 
		index(t,"T1_I1") 
		noparallel_index(t,"T1_I1") 
	*/ 
--	count(*) as nrw,
--	count(distinct sys_op_lbid(49721,'L',t.rowid)) as nlb,
--	count(distinct hextoraw(sys_op_descend("DATE_ORD")||sys_op_descend("SEQ_ORD"))) as ndk,
	sys_op_countchg(substrb(t.rowid,1,15),5) as clf 
from 
	"TEST_USER"."T1"  t 
where 
	"DATE_ORD" is not null 
or	"SEQ_ORD" is not null
;

spool off


doc

--------------------------------------------------------------------------------------

Example of the SQL used by dbms_stats for a bitmap index.
Note that 
	nrw (number of rows) is very special
	clf (clustering factor) is not calculated
The 497796 is the object id of the index

select 
	/*+ cursor_sharing_exact dynamic_sampling(0) no_monitoring no_expand index(t,"T1_I1") noparallel_index(t,"T1_I1") */ 
	count(distinct sys_op_lbid(49796,'R',t.rowid)) as nrw,
	count(distinct sys_op_lbid(49796,'L',t.rowid)) as nlb,
	count(distinct "DATE_ORD") as ndk,
	null as clf 
from "TEST_USER"."T1"  t

--------------------------------------------------------------------------------------

Example of the SQL used by dbms_stats for the primary key of an IOT without overflow
Note
	nrw (number of rows) is back to count(*)
	ndk (number of distinct keys) has to match nrw - it's a primary key
	clf is meaningless for an IOT without overflow

select 
	/*+ cursor_sharing_exact dynamic_sampling(0) no_monitoring no_expand index_ffs(t,"T1_PK") */ 
	count(*) as nrw,
	count(distinct sys_op_lbid(49799,'L',t.rowid)) as nlb,
	null as ndk,
	null as clf 
from "TEST_USER"."T1"  t 
where "DATE_ORD" is not null or "SEQ_ORD" is not null

--------------------------------------------------------------------------------------


Example of the SQL used by dbms_stats for the primary key of an IOT WITH overflow
Note
	clf is now telling us about the scattering of the Overflow

select 
	/*+ cursor_sharing_exact dynamic_sampling(0) no_monitoring no_expand index(t,"T1_PK") */ 
	count(*) as nrw,
	count(distinct sys_op_lbid(49799,'L',t.rowid)) as nlb,
	null as ndk,
	sys_op_countchg(sys_op_lbid(49799,'O',"SMALL_VC"),1) as clf 
from "TEST_USER"."T1"  t 
where "DATE_ORD" is not null or "SEQ_ORD" is not null


--------------------------------------------------------------------------------------

Example of the SQL used by dbms_stats for a secondary key index on an IOT
The index is on the small_vc2 column (the code is the same with or without overflow)

Note
	ndk (number of distinct keys) counts the appearance of the indexed column
	clf is using another parameter value (G) to identify what it is counting

select 
	/*+ cursor_sharing_exact dynamic_sampling(0) no_monitoring no_expand index(t,"T1_I1") */ 
	count(*) as nrw,
	count(distinct sys_op_lbid(49807,'L',t.rowid)) as nlb,
	count(distinct "SMALL_VC2") as ndk,
	sys_op_countchg(sys_op_lbid(49807,'G',t.rowid),1) as clf 
from "TEST_USER"."T1"  t 
where "SMALL_VC2" is not null

----------------------------------------------------------------------------------------

Example of SQL relating to the secondary index 'guess' percentage, 
	Note the use of global hints:  use_hash(p1.t2)
	Note also that we seem to use a sample from the secondary index.

select 
	/*+ cursor_sharing_exact dynamic_sampling(0) no_monitoring ordered use_hash(pi.t2) */ 
	case 
		when count(*)=0 then 100 
		else round (
			count	(
				case 
					when substr(i.gdba,7,9)=substr(pi.lbid,7,9) then 1 
					else null 
				end
				)/count(*)*100
		     ) 
	end 
	from 	(
		select /*+ index_ffs(t1,"T1_I1") */ 
			sys_op_lbid(49807,'G',t1.rowid) gdba,
			t1.rowid rid 
		from 
			"TEST_USER"."T1" 
			sample block(19.23076923076923076923076923076923076923) t1
		) i, 
		(
		select /*+ index_ffs(t2,"T1_PK") */ 
			sys_op_lbid(49806,'L',t2.rowid) lbid, 
			t2.rowid rid 
		from
			"TEST_USER"."T1" t2
		) pi 
	where 
		substr(i.rid,10)=substr(pi.rid,10)

--------------------------------------------------------------------------------------

#



