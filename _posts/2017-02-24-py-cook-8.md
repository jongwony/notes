---
layout: post
title: Python cookbook Chapter 8 한글
tags: ['python', 'docs', 'class', 'object', '한글']
progress: 40
---

<div id='index-table'>
<h2>8. Classes and Objects</h2>
</div>

- - -

<div class='warn'>
이 문서는 Python Coobook 3rd edition - O'REILLY, David Beazley & Brian K. jones 를 참고한 것이며 개인적인 번역으로 인한 오역이 있을 수 있습니다.<br> <a href="//wikidocs.net/book/1">Python을 완전히 처음 접하는 경우</a>에는 적합하지 않습니다.<br>
</div>

이 장의 주된 포커스는 클래스 정의와 연관된 일반적인 프로그래밍 패턴에 대한 레시피를 제시하는 것입니다. 주제는 일반적인 Python 기능과, 특수한 메서드의 사용, 캡슐화 기술, 상속, 메모리 관리 및 유용한 디자인 패턴을 지원하는 객체 작성을 포함합니다.

## 8.1. Changing the String Representation of Instances

#### Problem

인스턴스를 출력하거나 보면서 생성된 결과를 좀 더 합리적인 것으로 변경하려고 합니다.

#### Solution

인스턴스의 문자열 표현의 변경을 위해서는 `__str__()`와 `__repr__()` 메서드를 정의합니다.

```python
class Pair:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return 'Pair({0.x!r}, {0.y!r})'.format(self)
    def __str__(self):
        return '({0.x!s}, {0.y!s})'.format(self)
```

`__repr__()` 메서드는 인스턴스의 코드 표현을 반환하며 이는 보통 인스턴스를 재생성하기 위해 입력하는 텍스트입니다.
`built-in repr()` 함수는 값을 검사할 때 대화식 인터프리터와 같이 이 텍스트를 반환합니다. `__str__()` 메서드는 인스턴스를 문자열로 변환하며 이는 `str()`와 `print()` 함수에 의해 결과가 생성됩니다.

```python
>>> p = Pair(3, 4)
>>> p
Pair(3, 4)      # __repr__() output
>>> print(p)
(3, 4)          # __str__() output
```

이 방법의 구현은 `formatting`을 사용하는 동안 어떻게 문자열 표현이 다른지도 보여줍니다.
특히, 특별한 `!r` 코드 `formatting`은 `__repr__()`의 결과가 기본적으로 `__str__()` 대신에 사용되어야 함을 가리킵니다.
앞의 클래스에서 이 실험을 시도할 수 있습니다.

```python
>>> p = Pair(3, 4)
>>> print('p is {0!r}'.format(p))
p is Pair(3, 4)
>>> print('p is {0})'.format(p))
p is (3, 4)
```

#### Discussion

`__repr__()`과 `__str__()`을 정의하는 것은 디버깅과 인스턴스 출력을 단순화 할 수 있는 것과 같이 종종 좋은 방법이 됩니다. 예를 들어 단지 인스턴스의 프린팅 또는 로깅에 의해 프로그래머가 좀 더 인스턴스 내용에 대한 유용한 정보를 볼 수 있을 것입니다.

`eval(repr(x)) == x`을 만족하는 텍스트를 생성하는 `__repr__()`의 출력은 표준적인 방법입니다.
이것이 불가능하거나 바라지 않는다면, 대신 `<and>`로 묶인 유용한 텍스트 표현을 만드는 것이 일반적입니다.

```python
>>> f = open('file.dat')
>>> f
"""<_io.TextIOWrapper name='file.dat' mode='r' encoding='UTF-8'>"""
```

`__str__()`가 정의되지 않았다면 `__repr__()`의 출력은 대체로써 사용됩니다.

Solution에서의 `format()` 사용은 약간 재미있어 보일 지 모르겠지만, `{0.x}` 서식 코드는 인수의 `x`속성을 0으로 지정합니다. 그러므로 다음 함수에서 `0`은 실제로 인스턴스 `self`입니다.

```python
def __repr__(self):
    return 'Pair({0.x!r}, {0.y!r})'.format(self)
```

이 구현의 대안으로 `%` 연산자를 다음과 같이 사용할 수도 있습니다.

```python
def __repr__(self):
    return 'Pair(%r, %r)' % (self.x, self.y)
```

## 8.2. Customizing String Formatting

#### Problem

`format()` 함수와 문자열 메서드를 통해 커스터마이징 된 서식 객체를 지원하려고 합니다.

#### Solution

문자열 서식을 커스터마이징하기 위해서는 클래스에 `__format__()` 메서드를 정의합니다.

```python
_formats = {
    'ymd' : '{d.year}-{d.month}-{d.day}',
    'mdy' : '{d.month}/{d.day}/{d.year}',
    'dmy' : '{d.day}/{d.month}/{d.year}'
}

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def __format__(self, code):
        if code == '':
            code = 'ymd'
            rmt = _formats[code]
        return fmt.format(d=self)
```

`Date` 클래스의 인스턴스가 이제 다음과 같이 서식 연산을 지원합니다.

```python
>>> d = Date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d, 'mdy')
'12/21/2012'
>>> 'The date is {:ymd}'.format(d)
'The date is 2012-12-21'
>>> 'The date is {:mdy}.'.format(d)
'The date is 12/21/2012'
```

#### Discussion

`__format__()` 메서드는 Python의 문자열 서식 기능에 `hook`을 제공합니다.
서식 코드를 번역하는 것이 전적으로 클래스 자체에 있다는 점이 중요합니다. 
그러므로 코드가 거의 모든 것이 될 수 있습니다. 예를 들어 다음 `datetime` 모듈을 고려해보면

```python
>>> from datetime import date
>>> d = date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d,'%A, %B, %d, %Y')
'Friday, December 21, 2012'
>>> 'The end is {:%d %b %Y}. Goodbye'.format(d)
'The end is {21 Dec 2012. Goodbye'
```

`built-in` 타입의 서식 지정을 위한 표준 규칙이 있습니다. 형식 지정을 위한 [`string` 모듈 문서](//docs.python.org/3/library/string.html)를 참고하시기 바랍니다.

## 8.3. Making Objects Support the Context-Management Protocol

#### Problem

`context-management`(`with` 문) 프로토콜을 지원하는 객체를 생성하려고 합니다.

#### Solution

`with` 문과 호환되는 객체를 생성하기 위해서 `__enter__()`와 `__exit__()` 메서드를 구현해야 합니다.
예를 들어 네트워크 연결을 제공하는 다음 클래스를 고려합니다.

```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = AF_INET
        self.type = SOCK_STREAM
        self.sock = None

    def __enter__(self):
        if self.sock is not None:
            raise RuntimeError('Already connected')
        self.sock = socket(self.family, self.type)
        self.sock.connect(self.address)
        return self.sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.sock.close()
        self.sock = None
```

이 클래스의 핵심 기능은 네트워크 연결을 나타내지만 처음에는 실제로 아무것도 하지 않습니다(연결을 설정하지 않습니다).
대신에, `with` 문을 사용하여 연결이 설정하고 닫습니다(필수적으로 필요에 따라).

```python
from functools import partial

conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
    # conn.__enter__() executes: connection open
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))
    # conn.__exit__() executes: connection closed
```

#### Discussion

컨텍스트 매니저 작성의 주요 원칙은 `with` 문의 사용으로 정의된 문장의 블록을 둘러 싸는 코드를 작성하는 것입니다. `with` 문이 처음에 도달하면 `__enter__()` 메서드가 트리거됩니다.
`__enter__()`의 반환 값은(있는 경우) `as` 한정자를 가리키는 변수로 저장됩니다.
그 후, `with` 문의 내부가 실행됩니다. 마지막으로 `__exit__()` 메서드가 정리를 위해 트리거됩니다.

이 제어 흐름은 예외가 있는 경우를 포함하여 `with` 문의 내부에서 무엇이 일어나는지 상관 없이 발생합니다.
사실 `__exit__()` 메서드의 세 인수는 예외를 보류하기 위한 예외 `type`, `value`, `traceback`을 포함합니다(있는 경우).
`__exit__()` 메서드가 예외 정보를 사용하거나 아무것도 하지 않고 결과로 `None`을 반환하여 이를 무시하도록 선택할 수 있습니다. 
`__exit__()`가 `true`를 반환한다면 예외는 아무 일 없이 `eith` 블록 바로 다음 문을 계속 실행하는 것처럼 정리됩니다.

한가지 이 방법의 미묘한 점은 `LazyConnection` 클래스가 여러 `with` 문의 중첩을 허용하는지의 여부입니다.
보시다시피 한번에 단일 소켓만 허용되며 소켓이 이미 사용 중일 때 반복된 `with`문이 시도되면 예외를 일으키게 됩니다.
이 제한을 다음과 같은 약간 다른 구현으로 해결할 수 있습니다.

```python
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = AF_INET
        self.type = SOCK_STREAM
        self.connections = []

    def __enter__(self):
        sock = socket(self.family, self.type)
        sock.connect(self.address)
        self.connections.append(sock)
        return sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.connections.pop().close()

# Example use
from functools import partial

conn = LazyConnection(('www.python.org', 80))
with conn as s1:
    ...
    with conn as s2:
        ...
        # s1 and s2 are independent sockets
```

두 번째 버전은 `LazyConnection` 클래스가 연결을 위한 팩토리의 일종으로 사용됩니다.
내부적으로 리스트가 스택으로 유지되기 위해 사용됩니다. `__enter__()`가 실행될 때마다 새로운 연결이 생성되고 스택에 추가됩니다. `__exit__()` 메서드는 단순히 마지막 연결을 스택에서 `pop`하고 닫습니다. 미묘하지만 위와 같이 한 번의 `with` 문 중첩으로 다중 연결이 생성됩니다.

컨텍스트 매니저는 파일, 네트워크 연결, `lock`과 같은 리소스를 관리할 필요가 있는 프로그램에 가장 일반적으로 사용됩니다.
이런 리소스의 핵심적인 부분은 올바르게 작동하기 위해 명시적으로 닫거나 해제해야 한다는 것입니다. 예를 들어 `lock`을 얻으면 그것을 해제해 주어야 하며, 그렇지 않으면 `deadlock`의 위험이 있습니다. `__enter__()`와 `__exit__()`을 구현과 `with` 문을 사용함으로써 이런 문제를 좀 더 쉽게 피할 수 있습니다. `__exit__()` 메서드의 정리 코드가 무엇이든 상관없이 실행이 보장되기 때문입니다.

컨텍스트 매니저의 대안이 되는 공식은 `contextmanager` 모듈에서 찾을 수 있습니다. [9.22장]()을 참고하시기 바랍니다.
이 장의 `thread-safe` 버전은 [12.6장]()에서 찾을 수 있습니다.

## 8.4. Saving Memory When Creating a Large Number of Instances

#### Problem

프로그램이 인스턴스의 매우 큰 수를 만들어내고(100만 단위) 많은 메모리를 사용합니다.

#### Solution

주로 간단한 데이터 구조로 사용되는 클래스의 경우 `__slots__` 속성을 클래스 정의에 추가함으로써 인스턴스 메모리 사용 영역을 크게 줄일 수 있습니다.

```python
class Date:
    __slots__ = ['year', 'month', 'day']
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day
```

`__slots__`를 정의할 때 Python은 인스턴스에 훨씬 더 컴팩트한 내부 표현을 사용합니다.
각 인스턴스가 `dictionary`로 구성되는 대신, 인스턴스가 `tuple` 또는 `list`와 유사한 작은 고정된 사이즈 배열을 생성합니다.
`__slots__` 지정자로 나열된 속성 이름은 이 배열 내의 특정 인덱스에 내부적으로 매핑됩니다.
슬롯 사용의 부작용은 새로운 속성이나 인스턴스를 더 이상 추가할 수 없다는 것입니다.
`__slots__` 지정자에 나열된 속성 이름으로만 제한됩니다.

#### Discussion

슬롯 사용으로 인한 메모리 절약은 저장된 속성의 수와 타입에 따라 다릅니다.
하지만 일반적으로 메모리 사용의 결과는 `tuple`에 저장되는 데이터와 비교됩니다.
설명하자면 단일 `Date` 인스턴스를 슬롯 없이 저장하는 것은 Python 64비트 버전에서 428 바이트의 메모리가 필요합니다. 슬롯이 정의된다면 156 바이트가 감소하게 됩니다.
한번에 큰 수의 날짜를 조작하는 프로그램에서 이는 전체적인 메모리 사용을 크게 줄여줍니다.

비록 슬롯이 일반적으로 사용되는 기능처럼 보이지만 대부분의 코드에서는 슬롯을 사용하지 않는게 좋습니다. Python의 많은 부분에서 일반적으로 `dictionary` 기반의 구현에 의존합니다.
추가로 슬롯 정의 클래스는 다중 상속 같은 기능을 제공하지 않습니다.
대부분 자주 사용되는 데이터 구조로 쓰는 클래스에서만 슬롯을 사용하는 것이 좋습니다(예. 프로그램이 특정 클래스 인스턴스를 백만 단위로 생성할 경우).

`__slots__`에 대한 일반적인 오해는 사용자가 인스턴스에 새로운 속성을 추가할 수 없도록하는 캡슐화 도구라는 것입니다. 비록 이런 `side effect`로 슬롯을 사용하더라도 이는 절대 원래 목적이 아닙니다. 대신 `__slots__`는 항상 성능 도구로 사용된 경향이 있습니다.

## 8.5. Encapsulating Names in a Class

#### Problem

클래스 인스턴스의 *Private* 데이터를 캡슐화하려 하지만 Python의 액세스 컨트롤 부족이 우려됩니다.

#### Solution

데이터 캡슐화를 위한 언어의 기능에 의존하는 것 보다는 Python 프로그래머들은 데이터와 메서드의 의도된 사용법에 관한 특정 명명 규칙을 준수하길 기대합니다.
첫 번째 규칙은 모든 이름이 단일 밑줄(`_`)로 시작하여 항상 내부적인 구현이라고 가정한다는 것입니다.

```python
class A:
    def __init__(self):
        self._internal = 0      # An internal attribute
        self.public = 1         # A public attribute

    def public_method(self):
        '''
        A public method
        '''
        ...

    def _internal_method(self):
        ...
```

Python은 실제로 내부 이름에 액세스하는 것을 막지는 않습니다. 하지만 그렇게 하면 무례하다는 인식이며, 코드가 깨지기도 쉽습니다.
밑줄 사용은 모듈 이름과 모듈 레벨 함수에도 사용된다는 점에 유의해야 합니다.
예를 들어, 밑줄로 시작하는 모듈 이름을 본적이 있다면(`_socket`) 내부적인 구현을 나타냅니다.
마찬가지로 `sys._getframe()`과 같은 모듈 레벨 함수 역시 아주 조심해서 사용하여야 합니다.

또한 밑줄 두개를 사용해서 시작하는(`__`) 이름의 클래스 내부 정의도 볼 수 있습니다.

```python
class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        ...

    def public_method(self):
        ...
        self.__private_method()
        ...
```

밑줄 두개를 사용하면 다른 이름으로 망가지게 됩니다. 특히 이전의 클래스에서 *private* 속성은 `_B__private`와 `_B__private_method`로 각각 이름이 바뀌게 됩니다. 이 시점에서 이름을 망가지게 하는 것이 어떤 목적을 위한 것인지 궁금할 수도 있습니다. 답은 상속이며 속성이 상속으로 인한 *override*를 할 수 없습니다.

```python
class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1      # Does not override B.__private

    # Does not overrice B.__private_method()
    def __private_method(self):
        ...
```

여기서 *private* 이름의 `__private`와 `__private_method`는 `B`클래스 기반의 이름과는 다른 `_C__private`와 `_C__private_method`로 바뀐 이름을 얻습니다.

#### Discussion

*private* 속성의 두가지 다른 규칙이 있다는 사실은(단일 밑줄 vs 두개의 밑줄) 어떤 스타일을 사용해야 하는지의 명확한 질문을 이끌어냅니다. 대부분의 코드에서 단일 밑줄로 시작하여 *nonpublic*한 이름을 만들어 낼 것입니다. 하지만 때론 코드가 서브 클래스를 포함할 것이고, 서브클래스로부터 숨겨야하는 내부적인 속성이 있습니다. 이때는 두개의 밑줄을 사용합니다.

예약어의 이름과 충돌하는 변수를 원할 때도 있을 것입니다. 이때는 단일 밑줄을 끝에 사용하는 것이 좋습니다.

```python
lambda_ = 2.0       # Trailing _ to avoid clash with lambda keyword
```

앞서 언급한 밑줄을 사용하지 않는 이유는 의도된 사용법에 대한 혼란을 피하기 위해서입니다(즉 *private* 변수를 가리키는 것 보다는 이름 충돌을 피하기 위한 방법으로 해석될 수 있습니다).
마지막에 단일 밑줄을 사용하여 이 문제를 해결할 수 있습니다.

## 8.6. Creating Managed Attributes

#### Problem

인스턴스 속성을 얻거나 설정하는 데 추가적인 처리(타입 체크 또는 유효성 검사)를 원합니다.

#### Solution

속성에 액세스하기위한 커스터마이즈의 간단한 방법은 *property*를 정의하는 것입니다.
예를 들어 이 코드는 속성의 타입 체크를 위해 간단하게 추가한 *property*를 정의합니다.

```python
class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError("Cannot delete attribute")
```

이전 코드에서 세가지 연관된 메소드가 있으며 모두 같은 이름이어야 합니다.
첫 번째 메서드는 `getter` 함수이며 `first_name`을 *property*로 설정합니다.
다른 두 메서드는 `first_name` *property*에 부가적으로 `setter`와 `deleter`가 첨부됩니다.
이는 `@first_name.setter`와 `@first_name.deleter` 데코레이터가 `first_name`이 이미 *property*로 `@property`를 이미 설정하지 않은 이상 정의되지 않는다는 점이 중요합니다.

*property*의 중요한 특징은 평범한 속성으로 보이지만 액세스가 자동으로 `getter`, `setter`와 `deleter` 메서드를 트리거한다는 것입니다.

```python
>>> a = Person('Guido')
>>> a.first_name    # Calls the getter
'Guido'
>>> a.first_name = 42
TypeError: Expected a string
>>> del a.first_name
AttributeError: Cannot delete attribute
```

*property*를 구현할 때 기본 데이터가(있다면) 여전히 어딘가에 저장이 되어야 합니다.
그러므로 메서드의 `get`과 `set`에서 실제 데이터가 있는 `_first_name` 속성을 직접 조작할 수 있습니다.
추가적으로 왜 `__init__()` 메서드에 `self._first_name` 대신 `self.first_name`이 설정되었는지 궁금할 것입니다.
이 예제에서 *property*의 전체적인 포인트는 속성을 설정할 때 타입 체크를 적용하는 것입니다.
그러므로 초기화하는 동안 이런 체킹 작업을 수행할 수도 있습니다.
`self.first_name`으로 설정함으로써 `set` 작업은 `setter` 메서드를 사용하는 것입니다(`self._first_name`에 액세스하여 우회하는 것과는 반대).

*property*들은 또한 이미 존재하는 `get`과 `set` 메서드로 정의될 수도 있습니다.

```python
class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError("Cannot delete attribute")

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)
```

#### Discussion

*property* 속성은 실제로 번들로 묶인 메서드 모음입니다. *property*를 가진 클래스를 검사한다면 *property* 자체 속성인 `fget`, `fset`, `fdel`라는 `raw method`를 찾아볼 수 있습니다.

```python
>>> Person.first_name.fget
<function Person.first_name at 0x1006a60e0>
>>> Person.first_name.fset
<function Person.first_name at 0x1006a6170>
>>> Person.first_name.fdel
<function Person.first_name at 0x1006a62e0>
```

일반적으로 `fget` 또는 `fset`을 직접 호출할 수는 없지만 *property*에 액세스 될 때 자동적으로 트리거됩니다.

*property*들은 속성 액세스에 대한 **추가적인 처리를 실제로 수행해야 하는 경우에만** 사용되어야 합니다.
때론 Java와 같은 언어를 사용하는 프로그래머들이 모든 액세스는 `getter`와 `setter`로 처리되어야 한다고 생각하는 경우가 있어 코드를 다음과 같이 작성합니다.

```python
class Person:
    def __init__(self, first_name):
        self.first_name = name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
```

실제로 이와 같이 어떤것도 추가된 것이 없는 *property*를 작성하지 마시길 바랍니다.
첫째로 다른 사람에게 코드를 장황하고 혼란스럽게 만들며 둘째로 프로그램이 훨씬 느려지게 됩니다.
마지막으로 실제로 디자인적인 이점이 없습니다. 특히 나중에 일반 속성을 핸들링할 때 추가적인 처리를 한다고 결정하면 기존 코드를 변경하지 않고 *property*로 승격시킬 수 있습니다.
이는 속성에 액세스한 코드의 구문이 변경되지 않고 남기 때문입니다.

*property*들은 계산된 속성을 정의하는 방법으로도 사용될 수 있습니다. 이런 속성들은 실제로 저장되지는 않지만 필요에 따라 계산됩니다.

```python
import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
```

여기서 *property*를 사용하면 `radius`, `area`, `perimeter`가 간단한 속성과 메서드 호출이 섞인 것이 아니라 단순한 속성으로만 액세스된다는 점에서 매우 균일한 인스턴스 인터페이스가 됩니다.

```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area      # Notice lack of ()
50.26548245743669
>>> c.perimeter # Notice lack of ()
25.132741228718345
```

*property*를 사용하면 우아한 프로그래밍 인터페이스가 제공되지만, 실제로 `getter` 및 `setter` 함수를 직접 사용할 수도 있습니다.

```python
>>> p = Person('Guido')
>>> p.get_first_name()
'Guido'
>>> p.set_first_name('Larry')
```

이는 종종 Python 코드가 시스템 또는 프로그램의 더 큰 인프라로 통합되는 상황에 발생합니다.
예를 들어 Python 클래스가 원격 프로시저 호출 또는 분산 객체를 기반으로 하는 대규모 분산처리 시스템에 플러그인 될 것입니다. 이러한 설정에서는 암묵적으로 호출하는 속성이 아닌 명시적으로 `get`/`set` 메서드(일반 메서드 호출)로 작업하는 것이 훨씬 쉽습니다.

마지막으로 반복적으로 *property*가 정의가 많은 다음과 같은 Python 코드를 작성하지 마십시오.

```python
class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Repeated property code, but for a different name (bad!)
    @property
    def last_name(self):
        return self._last_name

    @last_name.setter
    def last_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._last_name = value
```

코드 반복은 거품이며, 에러가 발생하기 쉽고, 잘못된 코드로 이어집니다. 결과적으로 *descriptor*나 *closure*를 사용하여 동일한 것을 달성하는 것이 더 좋은 방법입니다.
[8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)과 [9.21장]()을 참고하시기 바랍니다.

## 8.7. Calling a Method on a Parent Class

#### Problem

서브클래스에서 *override*된 메서드 대신 부모 클래스에서 메서드를 호출하길 원합니다.

#### Solution

부모(또는 `superclass`)에서 메서드를 호출하려면 `super()` 함수를 사용합니다.

```python
class A:
    def spam(self):
        print('A.spam')

class B(A):
    def spam(self):
        print('B.spam')
        super().spam()      # Call a parent spam()
```

`super()`의 매우 일반적인 사용은`__init__()` 메서드를 처리하여 부모가 제대로 초기화 되었는지 확인하는 것입니다.

```python
class A:
    def __init__(self):
        self.x = 0

class B(A):
    def __init__(self):
        super().__init__()
        self.y = 1
```

또 다른 `super()`의 일반적인 사용은 코드에서 Python의 특수한 메서드를 *override*하는 것입니다.

```python
class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)    # Call original __setattr__
        else:
            setattr(self._obj, name, value)
```

이 코드에서 `__setattr__()`의 구현은 이름 체크를 포함합니다. 만일 이름이 밑줄(`_`)로 시작한다면 `super()`를 사용하여 `__setattr__()`의 원래 구현된 것을 호출합니다.
그렇지 않으면 내부적으로 보유한 객체 `self._obj`에 위임합니다.
약간은 흥미로워 보이지만, `super()`는 명시적으로 기본 클래스가 나열되지 않은 경우에도 동작합니다.

#### Discussion

`super()` 함수의 올바른 사용은 실제로 Python의 가장 이해하기 힘든 점 중 하나입니다.
때로는 다음과 같이 부모의 메서드를 직접 호출하는 코드를 보게 되기도 합니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')
```

비록 대부분의 코드에서 동작하지만, 다중 상속을 포함하는 고급 코드에서 이상한 문제가 발생할 수 있습니다. 예를 들어 다음과 같은 코드를 보시기 바랍니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')

class B(Base):
    def __init__(self):
        Base.__init__(self)
        print('B.__init__')

class C(A, B):
    def __init__(self):
        A.__init__(self)
        B.__init__(self)
        print('C.__init__')
```

이 코드를 실행한다면 `Base.__init__()` 메서드가 아래와 같이 두번 호출되는 것을 볼 수 있을 것입니다.

```python
>>> c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
```

`Base.__init__()` 이중 호출이 해가 되진 않지만 그렇지 않을 수도 있습니다.
만일 다른 방법으로는 `super()`를 사용하도록 코드를 바꾸면 모든 코드가 작동됩니다.

```python
class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A, B):
    def __init__(self):
        super().__init__()      # Only one call to super() here
        print('C.__init__')
```

이 새로운 버전을 사용할 때 `__init__()` 메서드가 한번만 호출 된다는 것을 알 수 있습니다.

```python
>>> c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
```

이 동작을 이해하려면 잠시 돌아와서 Python이 상속을 구현하는 방법에 대해 설명해야 합니다.
정의한 모든 클래스에 대해 Python은 *MRO(method resolution order)* 리스트로 알려진 것을 계산합니다.
*MRO* 리스트는 단순히 모든 *base* 클래스들의 *linear ordering*입니다.

```python
>>> C.__mro__
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class '__main__.Base'>, <class 'object'>)
```

상속을 구현하기 위해 Python은 가장 왼쪽 클래스로 시작하여 첫번째 속성이 매치될 때까지 *MRO* 리스트의 클래스를 통해 왼쪽에서 오른쪽으로 동작합니다.

*MRO* 목록 자체의 실제 결정은 **C3 Linearization**라고 알려진 기술을 사용하여 수행됩니다.
너무 수학으로 깊이 들어가지 않고 설명하자면 실제로 3개의 제약 조건이 있는 부모 클래스로 부터의 *MRO merge sort*입니다.

- 자식 클래스는 부모 클래스 이전에 체크한다.  
- 여러 부모는 나열된 순서대로 체크한다.  
- 다음 클래스에 대해 두가지 유효한 선택 사항이 있는 경우 첫 번째 부모에서 하나를 선택한다.

솔직히 꼭 알아야 할 것은 정의하고자 하는 거의 모든 클래스의 계층 구조에서 *MRO* 리스트에서 클래스의 순서가 *의미가 있다*는 것입니다.

`super()` 함수를 사용할 때는 Python이 *MRO*의 다음 클래스부터 시작하여 검색을 계속 합니다.
매번 재정의된 메서드가 연속적으로 `super()`를 사용하고 한번만 호출하는 한, 컨트롤은 완전히 전체적인 *MRO* 리스트를 통해 작동하고 각 메서드가 한번만 호출될 것입니다. 이는 두번째 예제에서 `Base.__init__()`가 두번 호출되지 않은 이유입니다.

`super()`의 놀라운 점은 바로 *MRO*의 다음 직접적인 클래스의 부모로 가지 않고 직접적인 부모가 아닌 클래스에서도 사용할 수 있다는 것입니다.

```python
class A:
    def spam(self):
        print('A.spam')
        super().spam()
```

이 클래스 사용을 시도하면 완전히 깨진 것을 알 수 있습니다.

```python
>>> a = A()
>>> a.spam()
A.spam
AttributeError: 'super' object has no attribute 'spam'
```

다중 상속에서 클래스를 사용하기 시작할 때 어떻게 되는지 보시기 바랍니다.

```python
class B:
    def spam(self):
    print('B.spam')

class C(A, B):
    pass
```

```python
>>> c = C()
>>> c.spam()
A.spam
B.spam
```

여기서 `A` 클래스의 `super().spam()` 사용을 보시면 사실 `A` 클래스와 전혀 관련이 없는 `B` 클래스의 `spam()` 메서드가 호출됩니다! 이는 `C` 클래스의 *MRO*가 모든 것을 설명해 줍니다.

```python
>>> C.__mro__
"<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>"
```

이런 식으로 `super()`를 사용하는 것은 `mixin` 클래스를 정의할 때 가장 일반적입니다.
[8.13장]()과 [8.18장]()을 참고하시기 바랍니다.

하지만 `super()`가 예상 밖의 메서드를 호출하기 때문에, 따라야 하는 몇가지 일반적인 규칙이 있습니다.
첫번째로, 상속에서 같은 이름을 가진 모든 메소드가 호환되는 호출 서명을 가지고 있는지 확인합니다(즉, 인수의 수나 이름이 같은지). 이러면 직접적인 부모가 아닌 클래스에서 메서드를 호출하려 할 때 `super()`를 거치지 않습니다.
두번째로, 일반적으로 최상위 클래스가 메서드 구현을 제공하여 *MRO*에서 발생하는 조회 체인이 실제 메서드 정렬에 따라 종료되도록 하는 것이 좋습니다.

`super()` 사용은 때론 Python 커뮤니티의 논쟁거리가 됩니다. 그러나 같은 조건에서는 모던 코드에서는 사용해야 할 것입니다. Raymond Hattinger는 블로그 포스트 [Python's `super()` considered Super!](//rhettinger.wordpress.com/2011/05/26/super-considered-super/)에 더 많은 예제와 `super()`가 놀라운 이유가 작성되어 있습니다.

## 8.8. Extending a Property in a Subclass

#### Problem

서브 클래스 내에서 부모 클래스에서 정의된 *property*의 기능을 확장하려고 합니다.

#### Solution

*property*를 정의하는 다음 코드를 살펴보겠습니다.

```python
class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise TypeError("Can't delete attribute")
```

다음은 `Person`의 상속 클래스이며 `name` *property*의 새 기능 확장의 예제입니다.

```python
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
```

다음은 새로운 클래스의 사용 예제입니다.

```python
>>> s = SubPerson('Guido')
Setting the name to Guido
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
Setting name to Larry
>>> s.name = 42
TypeError: Expected a string
```

*property*의 메서드 중 하나만 확장하려는 경우 다음과 같은 코드를 사용합니다.

```python
class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Gettinig name')
        return super().name
```

또는 반대로 `setter`만 확장하려는 경우엔 다음 코드를 사용합니다.

```python
class SubPerson(Person):
    @Person.name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)
```

#### Discussion

서브클래스에서 *property*의 확장은 단일 메서드와는 달리 *property*가 `getter`, `setter`, `deleter` 메서드의 컬렉션으로 정의된다는 사실과 관련된 여러가지 매우 미묘한 문제를 일으킵니다. 그러므로 *property*를 확장할 때 모든 메서드를 재정의할 것인지 그 중 한가지 메서드만 재정의할 것인지 알 필요가 있습니다.

첫 번째 예제에서 모든 *property* 메서드가 재정의되었습니다. 각 메서드 내에서 `super()` 가 이전 구현을 호출하는데 사용됩니다. `setter` 함수의 `super(SubPerson, SubPerson).name.__set__(self, value)` 사용에서 실수는 없습니다.
`setter`의 이전 구현을 위임하기 위해 컨트롤을 이전에 `name` *property*로 정의된 `__set__()` 메서드를 통해 전달해야 합니다.
하지만 이 메서드를 얻는 방법은 인스턴스 변수 대신 클래스 변수로 액세스하는 것 뿐입니다. 이는 `super(SubPerson, SubPerson)` 작업에서 발생합니다.

하나의 메서드만 재정의할 경우 `@property` 단독 사용으로는 충분하지 않습니다. 예를 들어 다음과 같은 코드는 동작하지 않습니다.

```python
class SubPerson(Person):
    @property   # Doesn't work
    def name(self):
        print('Getting name')
        return super().name
```

결과 코드를 시도하면 `setter` 함수가 완전히 사라진 것을 알 수 있습니다.

```python
>>> s = SubPerson('Guido')
AttributeError: cannot set attribute
```

대신, 다음 코드로 바꾸어야 합니다.

```python
class SubPerson(Person):
    @Person.getter
    def name(self):
        print('Getting name')
        return super().name
```

이렇게 하면 모든 이전에 정의된 *property* 메서드들이 복사되고, `getter` 함수가 치환됩니다.
이제 예상대로 작동합니다.

```python
>>> s = SubPerson('Guido')
>>> s.name
Getting name
'Guido'
>>> s.name = 'Larry'
>>> s.name
Getting name
'Larry'
>>> s.name = 42
TypeError: Expected a string
```

이 Solution에서는 하드코딩된 클래스 이름 `Person`을 보다 일반적인 것으로 대체할 수 있는 방법이 없습니다.
어떤 Base 클래스가 *property*를 정의했는지 모르는 경우에는 모든 *property* 메서드가 재정의되고 `super()`가 이전 구현으로 컨트롤을 전달하는 데 사용되는 방법을 사용해야 합니다.

이 장에서 보인 첫 번째 기술은 [8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)에 설명된 *descriptor*로 사용될 수도 있다는 것에 주목할 가치가 있습니다. 예를 들면

```python
# A descriptor
class String:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        instance.__dict__[self.name] = value

# A class with a descriptor
class Person:
    name = String('name')
    def __init__(self, name):
        self.name = name

# Extending a descriptor with a property
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
```

마지막으로, 이 글을 읽을 때쯤 `setter`와 `deleter` 메서드의 서브클래싱이 어느정도 단순화 될 수 있다는 점에 주목할만한 가치가 있습니다.
위 방법은 여전히 잘 동작하지만 [Python's issues page](//bugs.python.org/issue14965)에서의 버그 리포트가 향후 Python 버전에서 보다 명확한 방법으로 해결 될 수 있습니다.

## 8.9. Creating a New Kind of Class or Instance Attribute

#### Problem

타입 체킹과 같은 몇가지 추가 기능과 함께 새로운 종류의 인스턴스 속성 유형을 생성하려고 합니다.

#### Solution

완전히 새로운 종류의 인스턴스 속성을 생성하려면 *descriptor* 클래스의 형태로 그 기능을 정의합니다. 다음은 예제입니다.

```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError('Expected an int')
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance.__dict__[self.name]
```

*descriptor*는 특별한 `__get__()`, `__set__()`, `__delete__()` 메서드 형태로 세가지 핵심 속성에 액세스하는 작업(`get`, `set`, `delete`)을 구현하는 클래스입니다.
이 메서드는 인스턴스를 입력으로 받아 동작합니다. 인스턴스의 기본 `dictionary`가 다음에 적절하게 조작됩니다.

*descriptor*를 사용하려면 *descriptor*의 인스턴스를 클래스 변수로써 클래스 정의에 배치합니다.

```python
class Point:
    x = Integer('x')
    y = Integer('y')
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

이렇게 할 때 모든 *descriptor* 속성에 액세스(`x` 또는 `y`)가 `__get__()`, `__set__()`, `__delete__()` 메서드에 의해 캡쳐됩니다.

```python
>>> p = Point(2, 3)
>>> p.x         # Calls Point.x.__get__(p, Point)
2
>>> p.y = 5     # Calls Point.y.__set__(p, 5)
>>> p.x = 2.3   # Calls Point.x.__set__(p, 2.3)
TypeError: Expected an int
```

입력으로 *descriptor*의 각 메서드가 조작되는 인스턴스를 받습니다. 요청된 작업을 수행하기 위해 기본 인스턴스 `dictionary`(`__dict__` 속성)이 적절하게 조작됩니다. *descriptor*의 `self.name` 속성은 실제 데이터를 인스턴스 `dictionary`에 저장하는 데 사용되는 `dictionary` 키를 보유합니다.

#### Discussion

디스크립터는 `@classmethod`, `@staticmethod`, `@property` 및 `__slots__` 명세를 포함하여 대부분의 Python 클래스 기능에 대한 기본 기술(magic)을 제공합니다.

*descriptor*를 정의함으로써 코어 인스턴스 작업(`get`, `set`, `delete`)을 매우 낮은 레벨에서 캡처할 수 있고 완전히 커스터마이즈 할 수 있습니다. 이로써 큰 힘을 주며 고급 라이브러리와 프레임워크의 작성자가 사용하는 가장 중요한 도구 중 하나입니다.

*descriptor*의 한가지 혼동되는 점은 각 인스턴스별 기반이 아니라 클래스 레벨에서만 정의될 수 있다는 것입니다. 따라서 다음과 같은 코드는 동작하지 않습니다.

```python
# Does NOT work
class Point:
    def __init__(self, x, y):
        self.x = Integer('x')   # No! Must be a class variable
        self.y = Integer('y')

        self.x = x
        self.y = y
```

또한, `__get__()` 메서드의 구현이 보기보다 까다롭습니다.

```python
# Descriptor attribute for an integer type-checked attribute
class Integer:
    ...
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]
    ...
```

`__get__()`이 다소 복잡해보이는 이유는 인스턴스 변수와 클래스변수간의 구별을 설명하기 위해서입니다.
*descriptor*가 클래스변수로 액세스되면 `instance` 인수가 `None`으로 설정됩니다.
이 경우 단순히 *descriptor* 인스턴스 자체를 반환하는 것이(비록 어떤 종류의 커스텀 처리도 가능하지만) 표준입니다.

```python
>>> P = Point(2, 3)
>>> p.x         # Calls Point.x.__get__(p, Point)
2
>>> Point.x     # Calls Point.x.__get__(None, Point)
<__main__.Integer object at 0x100671890>
```

*descriptor*는 때론 *decorator*나 *metaclass*들을 포함하는 더 큰 프레임워크의 한 구성요소일 뿐입니다. 따라서 이들의 사용은 알게 모르게 숨어있을 수 있습니다.
예를 들어 다음은 클래스와 관련된 보다 클래스 *decorator*를 포함하는 고급 *descriptor* 기반의 코드입니다.

```python
# Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError('Expected ' + str(self.expected_type))
        instance.__dict__[self.name] = value

    def __delete__(self, instance):
        del instance__dict__[self.name]

# class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

마지막으로 특정 클래스의 단일 속성에 대한 액세스를 커스터마이즈하기만 하려면 *descriptor*를 작성하지 않아야합니다. 이는 [8.6장](#86-creating-managed-attributes)에서 설명한 대로 *property*를 사용하는 것이 더 쉽습니다.
*descriptor*는 코드 재사용이 많은 상황에서 더 유용합니다(즉, 수백가지 코드에서 *descriptor*가 제공하는 기능을 사용하거나 라이브러리 기능으로 제공할 경우를 원하는 경우)

## 8.10. Using Lazily Computed Properties

#### Problem

읽기 전용 속성을 액세스시에만 계산되는 *property*로 정의하려고 합니다.
하지만 한번 액세스되면 변수가 캐시되어 각 액세스에서 다시 계산하진 않으려고 합니다.

#### Solution

*lazy* 속성을 정의하는 효율적인 방법은 다음과 같이 *descriptor* 클래스를 사용하는 것입니다.

```python
class lazyproperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            value = self.func(instance)
            setattr(instance, self.func.__name__, value)
            return value
```

이 코드를 활용하려면 다음과 같은 클래스에서 사용할 수 있습니다.

```python
import math

class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    @lazyproperty
    def area(self):
        print('Computing area')
        return math.pi * self.radius ** 2

    @lazyproperty
    def perimeter(self):
        print('Computing perimeter')
        return 2 * math.pi * self.radius
```

다음 대화 세션은 동작 방법을 설명합니다.

```python
>>> c = Circle(4.0)
>>> c.radius
4.0
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.perimeter
Computing perimeter
25.132741228718345
>>> c.perimeter
25.132741228718345
```

"Computing area"와 "Computing perimeter" 메시지가 한번만 나타난다는 것을 주의깊게 관찰하시기 바랍니다.

#### Discussion

많은 경우 *lazy*하게 계산된 속성을 갖는 전체적인 포인트는 성능의 향상입니다.
예를 들어 실제로 어딘가 필요하지 않은 이상 변수 계산을 피합니다. 위의 Solution은 단지 이 작업만 수행하지만 매우 효율적인 방법으로 *descriptor*의 미묘한 기능을 활용하게 됩니다.

다른 장에도 소개되었듯이([8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)), 클래스 정의에 *descriptor*가 배치될 때 `__get__()`, `__set__()`, `__delete__()` 메서드가 속성 액세스시에 트리거됩니다.
하지만 *descriptor*가 `__get__()` 메서드만 정의할 경우 평소보다 바인딩이 훨씬 약합니다.
특히 `__get__()` 메서드가 액세스되는 속성이 기본 인스턴스 `dictionary`에 없는 경우에만 시작됩니다.

이 `lazyproperty` 클래스는 `__get__()` 메서드가 *property* 자체와 동일한 이름을 사용하여 인스턴스에 계산된 값을 저장하도록 함으로써 활용됩니다. 이렇게 함으로써 값은 인스턴스 `dictionary`에 저장되고 *property*의 추가적인 계산이 비활성화됩니다.
예제를 좀 더 자세히 들여다봄으로써 이를 관찰할 수 있습니다.

```python
>>> c = Circle(4.0)
>>> # Get instance variables
>>> vars(c)
{'radius': 4.0}
>>> # Compute area and observe variables afterward
>>> c.area
Computing area
50.26548245743669
>>> vars(c)
{'area': 50.26548245743669, 'radius': 4.0}
>>> # Notice access doesn't invoke property anymore
>>> c.area
50.26548245743669
>>> # Delete the variable and see property trigger again
>>> del c.area
>>> vars(c)
{'radius': 4.0}
>>> c.area
Computing area
50.26548245743669
```

이 장의 한가지 단점은 계산된 값이 생성된 후에 변경 가능하다는 것입니다. 예를 들면

```python
>>> c.area
Computing area
50.26548245743669
>>> c.area = 25
>>> c.area
25
```

이를 고려한다면 다음과 같이 약간 덜 효율적인 구현을 사용할 수 있습니다.

```python
def lazyproperty(func):
    name = '_lazy_' + func.__name__
    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy
```

이 버전을 사용한다면 `set` 연산이 허용되지 않는다는 것을 알 수 있습니다.

```python
>>> c = Circle(4.0)
>>> c.area
Computing area
50.26548245743669
>>> c.area
50.26548245743669
>>> c.area = 25
AttributeError: cannot set attribute
```

그러나 단점은 모든 `get` 연산이  *property*의 `getter` 함수를 통해 라우트되어야 한다는 점입니다.
이는 원래의 Solution에서와 마찬가지로 단순히 인스턴스 `dictionary`의 값을 찾는 것 보다는 효율적이지 않습니다.

*property*와 속성 변경의 추가 사항은 [8.6장](#86-creating-managed-attributes), *descriptor*는 [8.9장](#89-creating-a-new-kind-of-class-or-instance-attribute)을 참고하시기 바랍니다.
