---
layout: post
title: Python cookbook Chapter 9 한글
tags: ['python', 'docs', '한글']
progress: 0
---

<div id='index-table'>
<h2>9. Metaprogramming</h2>
</div>

소프트웨어 개발의 가장 중요한 만트라 중 하나는 "반복하지 말라"는 것입니다.
즉, 자주 반복되는 코드(또는 소스 코드 복사 붙여넣기)를 생성하는 문제가 발생할 때마다 보다 세련된 솔루션을 찾는 것이 좋습니다.
Python에서는 이러한 문제를 *Metaprogramming*의 카테고리에서 해결합니다.
메타 프로그래밍은 코드 조작(기존 코드 수정, 생성, wrapping)을 주요 목표로 하는 함수 및 클래스를 만드는 것입니다.
이 장의 주요 기능은 *decorator*, *class decorator*, *metaclass*들을 포함합니다.
하지만 서명 객체, `exec()`로 코드 실행, 함수 및 클래스 내부 검사 등 다양하고 유용한 토픽이 포함됩니다.
이 챕터의 주 목적은 다양한 메타프로그래밍 기법을 알아보고 Python의 동작을 입맛에 맞게 커스터마이징 할 수 있는 예제를 제공하는 것입니다.

## 9.1. Putting a Wrapper Around a Function

#### Problem

추가적인 프로세스(logging, timing 등)를 추가하는 함수 주위에 *wrapper layer*를 두려고 합니다.

#### Solution

추가적인 코드로 함수를 *wrap* 할 필요가 있다면 *decorator* 함수를 정의합니다.

```python
import time
from functools import wraps

def timethis(func):
    '''
    Decorator that reports the execution time
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result

    return wrapper
```

다음은 *decorator*의 사용 예입니다.

```python
>>> @timethis
... def countdown(n):
...     while n > 0:
...         n -= 1
...
>>> countdown(100000)
countdown 0.008917808532714844
>>> countdown(10000000)
countdown 0.87188299392912
```

#### Discussion

*decorator*는 함수를 input으로 받고 새로운 함수를 output으로 리턴하는 함수입니다. 다음과 같은 코드를 작성할 때마다

```python
@timethis
def countdown(n):
    ...
```

다음과 같은 별도의 단계로 수행된 것과 같습니다.

```python
def countdown(n):
    ...
countdown = timethis(countdown)
```

*built in decorator*인 `@staticmethod`, `@classmethod`, `@property` 또한 같은 방식으로 동작합니다.
예를 들어 다음 두 코드는 동일합니다.

```python
class A:
    @classmethod
    def method(cls):
        pass

class B:
    # Equivalent definition of a class method
    def method(cls):
        pass
    method = classmethod(method)
```

*decorator* 내의 코드는 이 장에서 `wrapper()` 함수로 보인 것과 같이 일반적으로 `*args`와 `**kwargs`를 사용하여 모든 인수를 허용하는 새로운 함수를 생성하는 것과 관련이 있습니다.
함수 내부에서 원래의 input 함수를 호출하고 결과를 반환합니다.
하지만 어떤 추가적인 코드를 추가하고 싶을 수도 있습니다(timing 같은).
그 새로 생성된 `wrapper` 함수는 결과로 반환되고 원래의 함수 대신 사용됩니다.

*decorator*는 일반적으로 *wrapping* 된 함수의 호출 시그니처 또는 반환 값을 바꾸지 않는다는 점이 중요합니다. `*args`와 `**kwargs` 사용은 모든 input  인수를 혀용할 수 있습니다.
*decorator*의 반환 값은 본래 *wrap*되지 않은 `func(*args, **kwargs)를 호출한 결과입니다. 이때 `func`는 원래 *unwrap*된 함수입니다.

*decorator*에 대해 처음 배울 때 보통 위에서 보인 것처럼 간단한 예제로 매우 쉽게 시작할 수 있습니다. 하지만 실제로 *decorator*를 작성하려고 하면 고려해야 할 미묘한 세부사항이 있습니다.
예를 들어 솔루션의 *decorator* `@wraps(func)` 사용은 잊어버리기 쉽지만 함수 메타데이터를 보존하는 것과 중요한 기술로 연관되어 있습니다. 이는 다음 장에서 다룹니다. 다음 여러 장에서 자신만의 *decorator* 함수를 작성하려는 경우 중요한 몇가지 세부 사항을 배웁니다.

## 9.2. Preserving Function Metadata When Writing Decorators

#### Problem

*decorator*를 작성했지만 함수에 적용할 때 `name`, `doc string`, `annotation`, 시그니처 호출과 같은 중요한 메타데이터를 잃습니다.

#### Solution

*decorator*를 정의할 때마다 wrapper 함수 기반의 `functools` 라이브러리로 부터 `@wraps` *decorator*를 적용하는 것을 항상 기억해야 합니다.

```python
import time
from functools import wraps

def timethis(func):
    '''
    Decorator that reports the execution time.
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper
```

다음은 *decorator* 사용의 예와 결과 함수 메타데이터를 테스트하는 것입니다.

```python
>>> @timethis
... def countdown(n:int):
...     '''
...     Counts down
...     '''
...     while n > 0:
...         n -= 1
...
>>> countdown(100000)
countdown 0.08917808532714844
>>> countdown.__name__
'countdown'
>>> countdown.__doc__
'\n\tCounts down\n\t'
>>> countdown.__annotations__
{'n': <class 'int'>}
```

#### Discussion

*decorator* 메타데이터를 복사하는 것은 *decorator* 작성에서 중요한 부분입니다. 만약 `@wraps` 사용을 잊어버리면 *decorate* 된 함수가 모든 종류의 유용한 정보를 잃는다는 것을 알게 될 것입니다.
예를 들어, 생략된 경우 마지막 예의 메타데이터는 다음과 같습니다.

```python
>>> countdown.__name__
'wrapper'
>>> countdown.__doc__
>>> countdown.__annotations__
[]
```

`@wraps` *decorator*의 중요한 특징은 wrap 된 함수를 `__wrapped__` 속성에서 사용가능하도록 하는 것입니다. 예를 들어 직접 wrap 된 함수에 액세스하려고 하는 경우

```python
>>> countdown.__wrapped__(100000)
>>>
```

`__wrapped__` 속성이 있으면 *decorate* 된 함수가 wrap 된 함수의 기본 서명을 제대로 표시합니다.

```python
>>> from inspect import signature
>>> print(signature(countdown))
(n:int)
```

가끔 일어나는 일반적인 질문은 wrap 된 원래 함수의 호출 시그니처를(`*args`, `**kwargs`를 사용하는 것과는 다르게) 직접 복사하는 *decorator*를 생성하는 방법입니다.
일반적으로 코드 문자열과 `exec()`의 *generator*와 관련된 트릭을 사용하지 않고 구현하기는 어렵습니다.
솔직히 일반적으로 `@wraps`를 사용하여 기본 함수 시그니처가 기본 `__wrapped__` 속성에 대한 액세스로 전파될 수 있다는 사실에 의존하는 것이 가장 좋습니다.
[9.16장]()에 시그니처에 대한 자세한 정보가 있습니다.

## 9.3. Unwrapping a Decorator

#### Problem

*decorator*가 함수에 적용되었지만 되돌리길 원하며, 원래의 wrap 되지 않은 함수의 액세스를 얻을 수 있도록 하려고 합니다.

#### Solution

*decorator*가 `@wraps`를 사용하여 적절하게 구현되었다고 가정하면[9.2장](#92-preserving-function-metadata-when-writing-decorators) 참조), 보통 원래의 함수에 `__wrapped__` 속성으로 액세스를 얻을 수 있습니다.

```python
@somedecorator
def add(x, y):
    return x + y

orig_add = add.__wrapped__
orig_add(3, 4)
7
```

#### Discussion

*decorator* 뒤에 wrap 되지 않은 함수에 직접 액세스하는 것은 디버깅, *introspection* 및 함수와 관련된 다른 작업에 유용할 수 있습니다.
하지만 이 장은 *decorator*의 구현이 `functools` 모듈의 `@wraps`를 사용하여 메타데이터를 적절하게 복사하거나 `__wrapped__` 속성으로 작접 설정한 경우에만 동작합니다.

만일 다중 *decorator*가 함수에 적용된 경우 `__wrapped__`로 액세스하는 행동은 현재 정의되지 않았으므로 피해야 합니다. Python 3.3에서는 모든 레이어를 건너 뜁니다. 예를 들어 다음과 같은 코드를 가정하면

```python
from functools import wraps

def decorator1(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Decorator 1')
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Decorator 2')
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def add(x, y):
    return x + y
```

다음은 *decorate*된 함수를 호출할 때와 원래의 함수를 `__wrapped__`를 통해 호출할 때 일어나는 상황입니다.

```python
>>> add(2, 3)
Decorator 1
Decorator 2
5
>>> add.__wrapped__(2, 3)
5
```

하지만 이 행동은 버그로 리포트 된 적이 있고([http://bugs.python.org/issue17482](//bugs.python.org/issue17482) 향후 릴리즈에서 적절한 데코레이터 체인을 파기하도록 변경될 지도 모릅니다.

마지막으로 모든 *decorator*가 `@wraps` 기능을 사용하지는 않으므로 설명한 대로 동작하지 않을 수 있음에 주의하시기 바랍니다. 특히, *built-in decorator* `@staticmethod`, `@classmethod`는 이 규칙을 따르지 않는 *descriptor* 객체를 생성합니다(대신 `__func__` 속성에서 원래의 함수로 저장됩니다).

#### Memo

버그에 대해 간단히 생각해보면 다음과 같습니다.
앞서 정의한 대로라면 다중의 *decorator*가 체인되었을 때 다음과 같이 동작되어야 합니다.

```python
def add2(x, y):
    return x + y
add2 = decorator1(add2)
add2 = decorator2(add2)
# Equivalent with add2 = decorator2(decorator1(add2))
```

정의한 대로 같은 결과가 나와야 하는데 다음과 같은 결과가 나옵니다.

```python
>>> add2(2, 3)
Decorator 2
Decorator 1
5
```

2017년인 현재 시점에 Python이 3.6으로 릴리즈 되었음에도 바뀌지 않았습니다(위 코드를 테스트 버전이 3.6이었습니다).

이미 2014년에 closed 된 버그 리포트이며 별로 대수롭게 생각하고 있는 것 같지는 않습니다.

## 9.4. Defining a Decorator That Takes Arguments

#### Problem

인수를 취하는 *decorator* 함수를 작성하려고 합니다.

#### Solution

예제를 통해 인수를 받아들이는 프로세스를 설명하겠습니다. 함수에 로깅을 추가하는 *decorator*를 작성하려고 하지만 사용자가 로깅 수준 및 기타 세부 사항을 인수로 지정할 수 있다고 가정합니다.
다음은 *decorator*를 정의하는 방법입니다.

```python
from functools import wraps
import logging

def logged(level, name=None, message=None):
    '''
    Add logging to a function. level is the logging level, name is the logger name, and message is the log message. If name and message aren't specified, they default to the function's module and name.
    '''
    def decorate(func):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__

        @wraps(func)
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)
        return wrapper
    return decorate

# Example use
@logged(logging.DEBUG)
def add(x, y):
    return x + y

@logged(logging.CRITICAL, 'example')
def spam():
    print('Spam!')
```

언뜻 보면 구현이 기교스럽지만 아이디어가 상대적으로 간단합니다. 가장 바깥의 함수 `logged()`가 바라는 인수를 받아들이고 *decorator* 내부 함수로 사용하게 만듭니다.
내부 함수 `decorate()`는 함수를 받아들이고 일반적으로 그 주위에 wrapper를 둡니다. 핵심 부분은 wrapper가 `logged()`에 전달된 인수를 사용할 수 있다는 것입니다.

#### Discussion

인수를 취하는 *decorator*를 작성하는 것은 기본적인 호출 시퀀스가 관련되어 있기 때문에 기교스럽습니다. 다음 코드의 경우

```python
@decorator(x, y, z)
def func(a, b):
    pass
```

*decoration* 프로세스는 다음과 같이 이루어집니다.

```python
def func(a, b):
    pass
func = decorator(x, y, z)(func)
```

`decorator(x, y, z)`의 결과는 호출 가능한 함수여야 하며 차례대로 함수를 input으로 가져와 wrap 하는 것임을 주의깊게 관찰하시기 바랍니다.
[9.7장]()에 인수를 취하는 *decorator*의 또 다른 예제를 참고하시기 바랍니다.

## 9.5. Defining a Decorator with User Adjustable Attributes

#### Problem

함수를 감싸는 *decorator* 함수를 작성하려고 하지만 런타임 시 *decorator*의 동작을 제어하는 데 사용할 수 있는 사용자가 조정 가능한 속성을 가져야 합니다.

#### Solution

`nonlocal` 변수 선언을 사용을 통해 내부 변수를 변경하는 접근자 함수를 도입함으로써 이전 장을 확장하는 솔루션이 있습니다.
그런 다음 접근자 함수는 wrapper 함수에 함수 속성으로 연결됩니다.

```python
from functools import wraps, partial
import logging

# Utility decorator to attach a function as an attribute of obj
def attach_wrapper(obj, func=None):
    if func is None:
        return partial(attach_wrapper, obj)
    setattr(obj, func.__name__, func)
    return func

def logged(level, name=None, message=None):
    '''
    Add logging to a function. level is the logging level, name is the loggername,
    and message is the log message. If name and message aren't specified,
    they default to the function's module and name
    '''
    def decorate(func):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__

        @wraps(func)
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)

        # attach setter functions
        @attach_wrapper(wrapper)
        def set_level(newlevel):
            nonlocal level
            level = newlevel

        @attach_wrapper(wrapper)
        def set_message(newmsg):
            nonlocal logmsg
            logmsg = newmsg
        
        return wrapper

    return decorate

# Example use
@logged(logging.DEBUG)
def add(x, y):
    return x + y

@logged(loging.CRITICAL, 'example')
def spam():
    print('Spam!')
```

다음은 정의 후 변경되는 다양한 속성을 보여주는 대화형 세션입니다.

```python
>>> import logging
>>> logging.basicConfig(level=logging.DEBUG)
>>> add(2, 3)
DEBUG:__main__:add
5

>>> # Change the log message
>>> add.set_message('Add called')
>>> add(2, 3)
DEBUG:__main___:Add called
5

>>> # Change the log level
>>> add.set_level(logging.WARNING)
>>> add(2, 3)
WARNING:__main__:Add called
5
```

#### Discussion

이 장의 핵심은 wrapper에 속성으로 연결되는 접근자 함수[`set_message()`, `set_level()`]에 있습니다.
이런 접근자 각각은 `nonlocal` 할당을 사용을 통해 내부 파라미터를 조정할 수 있게 합니다.

이 장의 놀라운 기능은 접근자 함수가 *decoration*(모든 *decorator*가 `@functools.wraps`를 사용한다면)의 다중 단계를 통해 전파될 것이라는 점입니다. 예를 들어 [9.2장]()의 `@timethis` *decorator* 같은 추가적인 *decorator*를 도입한다고 하면 다음과 같이 코드를 작성합니다.

```python
@timethis
@logged(logging.DEBUG)
def countdown(n):
    while n > 0:
        n -= 1
```

접근자 메서드가 여전히 동작한다는 것을 알 수 있습니다.

```python
>>> countdown(10000000)
DEBUG:__main__:countdown
countdown 0.8198461532592773
>>> countdown.set_level(logging.WARNING)
>>> countdown.set_message("Counting down to zero")
>>> countdown(10000000)
WARNING:__main__:Counting down to zero
countdown 0.8225970268249512
```

*decorator*가 다음과 같이 반대로 구성되어 있는 경우 여전히 모두 똑같은 방식으로 동작한다는 것을 알 수 있습니다.

```python
@logged(logging.DEBUG)
@timethis
def countdown(n):
    while n > 0
        n -= 1
```

보이진 않았지만 다양한 설정 값을 반환하는 접근자 함수는 다음과 같은 추가 코드를 추가함으로써 쉽게 작성할 수 있습니다.

```python
...
@attach_wrapper(wrapper)
def get_level():
    return level

# Alternative
wrapper.get_level = lambda: level
```

한가지 매우 미묘한 측면은 처음에 접근자 함수를 사용하는 것으로 선택하는 것입니다.
예를 들어 다음과 같은 함수 속성에 대한 직접적인 액세스를 기반으로하는 대체 공식을 고려할 수 있습니다.

```python
...
@wraps(func)
def wrapper(*args, **kwargs):
    wrapper.log.log(wrapper.level, wrapper.logmsg)
    return fuunc(*args, **kwargs)

# Attach adjustable attributes
wrapper.level = level
wrapper.logmsg = logmsg
wrapper.log = log
...
```

이런 접근은 맨 위에 있는 *decorator*일 경우에만 동작합니다.
다른 *decorator*가 상단에 적용되어 있을 경우(`@timethis` 예로 들자면), 기본 속성을 숨기고 그것을 수정을 위해 사용할 수 없도록 만듭니다. 접근자 함수를 사용하면 이런 제한을 피할 수 있습니다.

마지막으로 [9.9장]()에서 볼 수 있듯 이 장에서 보인 솔루션은 클래스로써 정의된 *decorator*로 대체할 수 있습니다.

## 9.6. Defining a Decorator That Takes an Optional Argument

#### Problem

#### Solution

#### Discussion