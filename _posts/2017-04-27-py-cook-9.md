---
layout: post
title: Python cookbook Chapter 9 한글
tags: ['python', 'docs', 'decorator', 'closure', 'metaprogramming', '한글']
progress: 60
---

<div id='index-table'>
<h2>9. Metaprogramming</h2>
</div>

- - -

<div class='warn'>
이 문서는 Python Coobook 3rd edition - O'REILLY, David Beazley & Brian K. jones 를 참고한 것이며 개인적인 번역으로 인한 오역이 있을 수 있습니다.<br> <a href="//wikidocs.net/book/1">Python을 완전히 처음 접하는 경우</a>에는 적합하지 않습니다.<br>
</div>

소프트웨어 개발의 가장 중요한 만트라 중 하나는 "반복하지 말라"는 것입니다.
즉, 자주 반복되는 코드(또는 소스 코드 복사 붙여넣기)를 생성하는 문제가 발생할 때마다 보다 세련된 솔루션을 찾는 것이 좋습니다.
Python에서는 이러한 문제를 *Metaprogramming*의 카테고리에서 해결합니다.
메타 프로그래밍은 코드 조작(기존 코드 수정, 생성, wrapping)을 주요 목표로 하는 함수 및 클래스를 만드는 것입니다.
이 장의 주요 기능은 *decorator*, *class decorator*, *metaclass*들을 포함합니다.
하지만 서명 객체, `exec()`로 코드 실행, 함수 및 클래스 내부 검사 등 다양하고 유용한 토픽이 포함됩니다.
이 챕터의 주 목적은 다양한 메타프로그래밍 기법을 알아보고 Python의 동작을 입맛에 맞게 커스터마이징 할 수 있는 예제를 제공하는 것입니다.

## 9.1. Putting a Wrapper Around a Function

#### Problem

추가적인 프로세스(logging, timing 등)를 추가하는 함수 주위에 *wrapper layer*를 두려고 합니다.

#### Solution

추가적인 코드로 함수를 *wrap* 할 필요가 있다면 *decorator* 함수를 정의합니다.

```python
import time
from functools import wraps

def timethis(func):
    '''
    Decorator that reports the execution time
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result

    return wrapper
```

다음은 *decorator*의 사용 예입니다.

```python
>>> @timethis
... def countdown(n):
...     while n > 0:
...         n -= 1
...
>>> countdown(100000)
countdown 0.008917808532714844
>>> countdown(10000000)
countdown 0.87188299392912
```

#### Discussion

*decorator*는 함수를 input으로 받고 새로운 함수를 output으로 리턴하는 함수입니다. 다음과 같은 코드를 작성할 때마다

```python
@timethis
def countdown(n):
    ...
```

다음과 같은 별도의 단계로 수행된 것과 같습니다.

```python
def countdown(n):
    ...
countdown = timethis(countdown)
```

*built in decorator*인 `@staticmethod`, `@classmethod`, `@property` 또한 같은 방식으로 동작합니다.
예를 들어 다음 두 코드는 동일합니다.

```python
class A:
    @classmethod
    def method(cls):
        pass

class B:
    # Equivalent definition of a class method
    def method(cls):
        pass
    method = classmethod(method)
```

*decorator* 내의 코드는 이 장에서 `wrapper()` 함수로 보인 것과 같이 일반적으로 `*args`와 `**kwargs`를 사용하여 모든 인수를 허용하는 새로운 함수를 생성하는 것과 관련이 있습니다.
함수 내부에서 원래의 input 함수를 호출하고 결과를 반환합니다.
하지만 어떤 추가적인 코드를 추가하고 싶을 수도 있습니다(timing 같은).
그 새로 생성된 `wrapper` 함수는 결과로 반환되고 원래의 함수 대신 사용됩니다.

*decorator*는 일반적으로 *wrapping* 된 함수의 호출 시그니처 또는 반환 값을 바꾸지 않는다는 점이 중요합니다. `*args`와 `**kwargs` 사용은 모든 input  인수를 혀용할 수 있습니다.
*decorator*의 반환 값은 본래 *wrap*되지 않은 `func(*args, **kwargs)를 호출한 결과입니다. 이때 `func`는 원래 *unwrap*된 함수입니다.

*decorator*에 대해 처음 배울 때 보통 위에서 보인 것처럼 간단한 예제로 매우 쉽게 시작할 수 있습니다. 하지만 실제로 *decorator*를 작성하려고 하면 고려해야 할 미묘한 세부사항이 있습니다.
예를 들어 솔루션의 *decorator* `@wraps(func)` 사용은 잊어버리기 쉽지만 함수 메타데이터를 보존하는 것과 중요한 기술로 연관되어 있습니다. 이는 다음 장에서 다룹니다. 다음 여러 장에서 자신만의 *decorator* 함수를 작성하려는 경우 중요한 몇가지 세부 사항을 배웁니다.

## 9.2. Preserving Function Metadata When Writing Decorators

#### Problem

*decorator*를 작성했지만 함수에 적용할 때 `name`, `doc string`, `annotation`, 시그니처 호출과 같은 중요한 메타데이터를 잃습니다.

#### Solution

*decorator*를 정의할 때마다 wrapper 함수 기반의 `functools` 라이브러리로 부터 `@wraps` *decorator*를 적용하는 것을 항상 기억해야 합니다.

```python
import time
from functools import wraps

def timethis(func):
    '''
    Decorator that reports the execution time.
    '''
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper
```

다음은 *decorator* 사용의 예와 결과 함수 메타데이터를 테스트하는 것입니다.

```python
>>> @timethis
... def countdown(n:int):
...     '''
...     Counts down
...     '''
...     while n > 0:
...         n -= 1
...
>>> countdown(100000)
countdown 0.08917808532714844
>>> countdown.__name__
'countdown'
>>> countdown.__doc__
'\n\tCounts down\n\t'
>>> countdown.__annotations__
{'n': <class 'int'>}
```

#### Discussion

*decorator* 메타데이터를 복사하는 것은 *decorator* 작성에서 중요한 부분입니다. 만약 `@wraps` 사용을 잊어버리면 *decorate* 된 함수가 모든 종류의 유용한 정보를 잃는다는 것을 알게 될 것입니다.
예를 들어, 생략된 경우 마지막 예의 메타데이터는 다음과 같습니다.

```python
>>> countdown.__name__
'wrapper'
>>> countdown.__doc__
>>> countdown.__annotations__
[]
```

`@wraps` *decorator*의 중요한 특징은 wrap 된 함수를 `__wrapped__` 속성에서 사용가능하도록 하는 것입니다. 예를 들어 직접 wrap 된 함수에 액세스하려고 하는 경우

```python
>>> countdown.__wrapped__(100000)
>>>
```

`__wrapped__` 속성이 있으면 *decorate* 된 함수가 wrap 된 함수의 기본 서명을 제대로 표시합니다.

```python
>>> from inspect import signature
>>> print(signature(countdown))
(n:int)
```

가끔 일어나는 일반적인 질문은 wrap 된 원래 함수의 호출 시그니처를(`*args`, `**kwargs`를 사용하는 것과는 다르게) 직접 복사하는 *decorator*를 생성하는 방법입니다.
일반적으로 코드 문자열과 `exec()`의 *generator*와 관련된 트릭을 사용하지 않고 구현하기는 어렵습니다.
솔직히 일반적으로 `@wraps`를 사용하여 기본 함수 시그니처가 기본 `__wrapped__` 속성에 대한 액세스로 전파될 수 있다는 사실에 의존하는 것이 가장 좋습니다.
[9.16장]()에 시그니처에 대한 자세한 정보가 있습니다.

## 9.3. Unwrapping a Decorator

#### Problem

*decorator*가 함수에 적용되었지만 되돌리길 원하며, 원래의 wrap 되지 않은 함수의 액세스를 얻을 수 있도록 하려고 합니다.

#### Solution

*decorator*가 `@wraps`를 사용하여 적절하게 구현되었다고 가정하면[9.2장](#92-preserving-function-metadata-when-writing-decorators) 참조), 보통 원래의 함수에 `__wrapped__` 속성으로 액세스를 얻을 수 있습니다.

```python
@somedecorator
def add(x, y):
    return x + y

orig_add = add.__wrapped__
orig_add(3, 4)
7
```

#### Discussion

*decorator* 뒤에 wrap 되지 않은 함수에 직접 액세스하는 것은 디버깅, *introspection* 및 함수와 관련된 다른 작업에 유용할 수 있습니다.
하지만 이 장은 *decorator*의 구현이 `functools` 모듈의 `@wraps`를 사용하여 메타데이터를 적절하게 복사하거나 `__wrapped__` 속성으로 작접 설정한 경우에만 동작합니다.

만일 다중 *decorator*가 함수에 적용된 경우 `__wrapped__`로 액세스하는 행동은 현재 정의되지 않았으므로 피해야 합니다. Python 3.3에서는 모든 레이어를 건너 뜁니다. 예를 들어 다음과 같은 코드를 가정하면

```python
from functools import wraps

def decorator1(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Decorator 1')
        return func(*args, **kwargs)
    return wrapper

def decorator2(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print('Decorator 2')
        return func(*args, **kwargs)
    return wrapper

@decorator1
@decorator2
def add(x, y):
    return x + y
```

다음은 *decorate*된 함수를 호출할 때와 원래의 함수를 `__wrapped__`를 통해 호출할 때 일어나는 상황입니다.

```python
>>> add(2, 3)
Decorator 1
Decorator 2
5
>>> add.__wrapped__(2, 3)
5
```

하지만 이 행동은 버그로 리포트 된 적이 있고([http://bugs.python.org/issue17482](//bugs.python.org/issue17482) 향후 릴리즈에서 적절한 데코레이터 체인을 파기하도록 변경될 지도 모릅니다.

마지막으로 모든 *decorator*가 `@wraps` 기능을 사용하지는 않으므로 설명한 대로 동작하지 않을 수 있음에 주의하시기 바랍니다. 특히, *built-in decorator* `@staticmethod`, `@classmethod`는 이 규칙을 따르지 않는 *descriptor* 객체를 생성합니다(대신 `__func__` 속성에서 원래의 함수로 저장됩니다).

#### Memo

버그에 대해 간단히 생각해보면 다음과 같습니다.
앞서 정의한 대로라면 다중의 *decorator*가 체인되었을 때 다음과 같이 동작되어야 합니다.

```python
def add2(x, y):
    return x + y
add2 = decorator1(add2)
add2 = decorator2(add2)
# Equivalent with add2 = decorator2(decorator1(add2))
```

정의한 대로 같은 결과가 나와야 하는데 다음과 같은 결과가 나옵니다.

```python
>>> add2(2, 3)
Decorator 2
Decorator 1
5
```

2017년인 현재 시점에 Python이 3.6으로 릴리즈 되었음에도 바뀌지 않았습니다(위 코드를 테스트 버전이 3.6이었습니다).

이미 2014년에 closed 된 버그 리포트이며 별로 대수롭게 생각하고 있는 것 같지는 않습니다.

## 9.4. Defining a Decorator That Takes Arguments

#### Problem

인수를 취하는 *decorator* 함수를 작성하려고 합니다.

#### Solution

예제를 통해 인수를 받아들이는 프로세스를 설명하겠습니다. 함수에 로깅을 추가하는 *decorator*를 작성하려고 하지만 사용자가 로깅 수준 및 기타 세부 사항을 인수로 지정할 수 있다고 가정합니다.
다음은 *decorator*를 정의하는 방법입니다.

```python
from functools import wraps
import logging

def logged(level, name=None, message=None):
    '''
    Add logging to a function. level is the logging level, name is the logger name, and message is the log message. If name and message aren't specified, they default to the function's module and name.
    '''
    def decorate(func):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__

        @wraps(func)
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)
        return wrapper
    return decorate

# Example use
@logged(logging.DEBUG)
def add(x, y):
    return x + y

@logged(logging.CRITICAL, 'example')
def spam():
    print('Spam!')
```

언뜻 보면 구현이 기교스럽지만 아이디어가 상대적으로 간단합니다. 가장 바깥의 함수 `logged()`가 바라는 인수를 받아들이고 *decorator* 내부 함수로 사용하게 만듭니다.
내부 함수 `decorate()`는 함수를 받아들이고 일반적으로 그 주위에 wrapper를 둡니다. 핵심 부분은 wrapper가 `logged()`에 전달된 인수를 사용할 수 있다는 것입니다.

#### Discussion

인수를 취하는 *decorator*를 작성하는 것은 기본적인 호출 시퀀스가 관련되어 있기 때문에 기교스럽습니다. 다음 코드의 경우

```python
@decorator(x, y, z)
def func(a, b):
    pass
```

*decoration* 프로세스는 다음과 같이 이루어집니다.

```python
def func(a, b):
    pass
func = decorator(x, y, z)(func)
```

`decorator(x, y, z)`의 결과는 호출 가능한 함수여야 하며 차례대로 함수를 input으로 가져와 wrap 하는 것임을 주의깊게 관찰하시기 바랍니다.
[9.7장]()에 인수를 취하는 *decorator*의 또 다른 예제를 참고하시기 바랍니다.

## 9.5. Defining a Decorator with User Adjustable Attributes

#### Problem

함수를 감싸는 *decorator* 함수를 작성하려고 하지만 런타임 시 *decorator*의 동작을 제어하는 데 사용할 수 있는 사용자가 조정 가능한 속성을 가져야 합니다.

#### Solution

`nonlocal` 변수 선언을 사용을 통해 내부 변수를 변경하는 접근자 함수를 도입함으로써 이전 장을 확장하는 솔루션이 있습니다.
그런 다음 접근자 함수는 wrapper 함수에 함수 속성으로 연결됩니다.

```python
from functools import wraps, partial
import logging

# Utility decorator to attach a function as an attribute of obj
def attach_wrapper(obj, func=None):
    if func is None:
        return partial(attach_wrapper, obj)
    setattr(obj, func.__name__, func)
    return func

def logged(level, name=None, message=None):
    '''
    Add logging to a function. level is the logging level, name is the loggername,
    and message is the log message. If name and message aren't specified,
    they default to the function's module and name
    '''
    def decorate(func):
        logname = name if name else func.__module__
        log = logging.getLogger(logname)
        logmsg = message if message else func.__name__

        @wraps(func)
        def wrapper(*args, **kwargs):
            log.log(level, logmsg)
            return func(*args, **kwargs)

        # attach setter functions
        @attach_wrapper(wrapper)
        def set_level(newlevel):
            nonlocal level
            level = newlevel

        @attach_wrapper(wrapper)
        def set_message(newmsg):
            nonlocal logmsg
            logmsg = newmsg
        
        return wrapper

    return decorate

# Example use
@logged(logging.DEBUG)
def add(x, y):
    return x + y

@logged(loging.CRITICAL, 'example')
def spam():
    print('Spam!')
```

다음은 정의 후 변경되는 다양한 속성을 보여주는 대화형 세션입니다.

```python
>>> import logging
>>> logging.basicConfig(level=logging.DEBUG)
>>> add(2, 3)
DEBUG:__main__:add
5

>>> # Change the log message
>>> add.set_message('Add called')
>>> add(2, 3)
DEBUG:__main___:Add called
5

>>> # Change the log level
>>> add.set_level(logging.WARNING)
>>> add(2, 3)
WARNING:__main__:Add called
5
```

#### Discussion

이 장의 핵심은 wrapper에 속성으로 연결되는 접근자 함수[`set_message()`, `set_level()`]에 있습니다.
이런 접근자 각각은 `nonlocal` 할당을 사용을 통해 내부 파라미터를 조정할 수 있게 합니다.

이 장의 놀라운 기능은 접근자 함수가 *decoration*(모든 *decorator*가 `@functools.wraps`를 사용한다면)의 다중 단계를 통해 전파될 것이라는 점입니다. 예를 들어 [9.2장]()의 `@timethis` *decorator* 같은 추가적인 *decorator*를 도입한다고 하면 다음과 같이 코드를 작성합니다.

```python
@timethis
@logged(logging.DEBUG)
def countdown(n):
    while n > 0:
        n -= 1
```

접근자 메서드가 여전히 동작한다는 것을 알 수 있습니다.

```python
>>> countdown(10000000)
DEBUG:__main__:countdown
countdown 0.8198461532592773
>>> countdown.set_level(logging.WARNING)
>>> countdown.set_message("Counting down to zero")
>>> countdown(10000000)
WARNING:__main__:Counting down to zero
countdown 0.8225970268249512
```

*decorator*가 다음과 같이 반대로 구성되어 있는 경우 여전히 모두 똑같은 방식으로 동작한다는 것을 알 수 있습니다.

```python
@logged(logging.DEBUG)
@timethis
def countdown(n):
    while n > 0
        n -= 1
```

보이진 않았지만 다양한 설정 값을 반환하는 접근자 함수는 다음과 같은 추가 코드를 추가함으로써 쉽게 작성할 수 있습니다.

```python
...
@attach_wrapper(wrapper)
def get_level():
    return level

# Alternative
wrapper.get_level = lambda: level
```

한가지 매우 미묘한 측면은 처음에 접근자 함수를 사용하는 것으로 선택하는 것입니다.
예를 들어 다음과 같은 함수 속성에 대한 직접적인 액세스를 기반으로하는 대체 공식을 고려할 수 있습니다.

```python
...
@wraps(func)
def wrapper(*args, **kwargs):
    wrapper.log.log(wrapper.level, wrapper.logmsg)
    return fuunc(*args, **kwargs)

# Attach adjustable attributes
wrapper.level = level
wrapper.logmsg = logmsg
wrapper.log = log
...
```

이런 접근은 맨 위에 있는 *decorator*일 경우에만 동작합니다.
다른 *decorator*가 상단에 적용되어 있을 경우(`@timethis` 예로 들자면), 기본 속성을 숨기고 그것을 수정을 위해 사용할 수 없도록 만듭니다. 접근자 함수를 사용하면 이런 제한을 피할 수 있습니다.

마지막으로 [9.9장]()에서 볼 수 있듯 이 장에서 보인 솔루션은 클래스로써 정의된 *decorator*로 대체할 수 있습니다.

## 9.6. Defining a Decorator That Takes an Optional Argument

#### Problem

`@decorator`와 같이 인수 없이 사용될 수 있거나 `@decorator(x, y, z)`와 같은 선택적 인수로 사용될 수 있는 단일 *decorator*를 작성하려고 합니다.
하지만 간단한 *decorator*와 인수를 취하는 *decorator*들 사이의 호출 규칙 차이로 인해 단순한 방법으로 이를 수행할 수 없는 것 처럼 보입니다.

#### Solution

다음은 그런 *decorator*를 정의하는 [9.5장]()에서 표시된 로깅 코드의 변형입니다.

```python
from functools import wraps, partial
import logging

def logged(func=None, *, level=logging.DEBUG, name=None, message=None):
    if func is None:
        return partial(logged, level=level, name=name, message=message)

    logname = name if name else func.__module__
    log = logging.getLogger(logname)
    logmsg = message if message else func.__name__

    @wraps(func)
    def wrapper(*args, **kwargs):
        log.log(level, logmsg)
        return func(*args, **kwargs)
    return wrapper

# Example use
@logged
def add(x, y):
    return x + y

@logged(level=logging.CRITICAL, name='example')
def spam():
    print('Spam!')
```

예제에서 볼 수 있듯이 *decorator*가 간단한 형태(`@logged`)나 선택적인 인수 지원(`@logged(level=logging.CRITICAL, name='example'`)) 모두 사용될 수 있습니다.

#### Discussion

이 장에서 다루는 문제는 실제로 프로그래밍의 일관성 중 하나입니다.
*decorator*를 사용할 때 대부분의 프로그래머는 예제에 표시된 것 처럼 전혀 인수를 적용하지 않거나 혹은 적용하는 데에 사용합니다.
기술적으로 말하자면 모든 인수가 선택적인 *decorator*를 다음과 같이 적용할 수 있습니다.

```python
@logged()
def add(x, y):
    return x + y
```

하지만 이는 일반적으로 사용하는 형식이 아니며 프로그래머가 추가적인 괄호를 사용하지 않으면 일반적으로 오류가 발생할 수 있습니다.
이 장은 *decorator*가 괄호의 유무에 상관없이 일관적으로 동작하게 해줍니다.

코드가 어떻게 동작하는지 이해하려면 *decorator*를 함수 및 호출 규칙에 적용하는 방법을 확실하게 이해해야 합니다. 간단한 *decorator*는 다음과 같습니다.

```python
# Example use
@logged
def add(x, y):
    return x + y
```

호출 시퀀스는 다음과 같습니다.

```python
def add(x, y):
    return x + y
add = logged(add)
```

이 경우 wrap 된 함수는 단순히 첫번째 인수로 전달됩니다.
그러므로 솔루션에서 `logged()`의 첫번째 인수는 wrap 되는 함수입니다.
다른 모든 인수에는 기본 값이 있어야 합니다.

인수를 취하는 *decorator*는 다음과 같습니다.

```python
@logged(level=logging.CRITICAL, name='example')
def spam():
    print('Spam!')
```

호출 시퀀스는 다음과 같습니다.

```python
def spam():
    print('Spam!')
spam = logged(level=logging.CRITICAL, name='example')(spam)
```

`logged()`를 처음 호출할 때 wrap 되는 함수는 전달되지 않습니다.
그러므로 *decorator*에서는 선택적이어야 합니다.
이는 차례로 다른 인수가 키워드에 의해 지정되도록 합니다.
나아가 인자가 전달되면 *decorator*는 함수를 받아들이고 그것을 wrap 하는 함수를 리턴해야 합니다([9.5장]() 참고). 이를 위해서는 이 솔루션에서 `functools.partial`과 관련된 영리한 트릭을 사용합니다.
특히, wrap 되는 함수를 제외하고 모든 인수가 고정되어 부분적으로 적용된 자체 버전을 반환합니다.
[7.8장]()에 `partial()` 사용에 대한 자세한 사항을 참고하시기 바랍니다.

## 9.7. Enforcing Type Checking on a FUnction Using a Decorator

#### Problem

일종의 assertion 또는 대조로 함수 인수의 타입 체킹을 선택적으로 시행하려고 합니다.

#### Solution

솔루션 코드를 보여주기 전에 이 장의 목적은 함수에 대한 input 인수에 타입 대조를 시행하는 방법입니다.
다음은 이 아이디어의 짧은 예제입니다.

```python
>>> @typeassert(int, int)
... def add(x, y):
...     return x + y
...
>>> add(2, 3)
5
>>> add(2, 'hello')
TypeError: Argument y must be class 'int'
```

이제 다음은 `@typeassert` *decorator*의 구현입니다.

```python
from inspect import signature
from functools import wraps

def typeassert(*ty_args, **ty_kwargs):
    def decorate(func):
        # If in optimized mode, disable type checking
        if not __debug__:
            return func

        # Map function argument names to supplied types
        sig = signature(func)
        bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments

        @wraps(func)
        def wrapper(*args, **kwargs):
            bound_values = sig.bind(*args, **kwargs)
            # Enforce type assertions across supplied arguments
            for name, value in bound_values.arguments.items():
                if name in bound_types:
                    if not isinstance(value, bound_types[name]):
                        raise TypeError('Argument {} must be {}'.format(name, bound_types[name]))
            return func(*args, **kwargs)
        return wrapper
    return decorate
```

이 *decorator*는 다소 유연함을 알 수 있고 함수 인수의 전체 또는 일부에 대해 타입을 지정할 수 있습니다.
또한 타입은 위치 또는 키워드로 지정될 수 있습니다. 다음은 그 예입니다.

```python
>>> @typeassert(int, z=int)
... def spam(x, y, z=42):
...     print(x, y, z)
...
>>> spam(1, 2, 3)
1, 2, 3
>>> spam(1, 'hello', 3)
1 hello 3
>>> spam(1, 'hello', 'world')
TypeError: Argument z must be class 'int'
```

## Discussion

이 장은 많은 중요하고 유용한 개념이 도입된 심화 *decorator* 예제입니다.

먼저, *decorator*의 한 측면은 함수 정의 시 한번만 적용된다는 것입니다.
어떤 경우 *decorator*로 추가한 기능을 비활성화 하고 싶을 때도 있을 것입니다.
이를 위해 단순히 *decorator* 함수가 unwrapped 함수를 리턴하게 하면됩니다.
이 솔루션에서 다음 코드는 글로벌 `__debug__` 변수 값이 `False`로 설정된 경우 수정되지 않은 함수를 반환합니다(Python이 인터프리터에 `-O` 또는 `-OO` 옵션을 사용하여 optimized 모드로 실행하는 경우).

```python
def decorate(func):
    # If in optimized mode, disable type checking
    if not __debug__:
        return func
```

다음으로 이 *decorator* 작성에서 까다로운 부분은 wrap 되는 함수의 인수 시그니처를 검사하고 동작하는 것입니다.
여기서 선택한 도구는 `inspect.signature()` 함수여야 합니다.
간단히 말해 *callable* 객체로 부터 시그니처 정보를 추출할 수 있게 합니다.

```python
>>> from inspect import signature
>>> def spam(x, y, z=42):
...     pass
...
>>> sig = signature(spam)
>>> print(sig)
(x, y, z=42)
>>> sig.parameters
mappingproxy(OrderedDict([('x', <Parameter at 0x10077a050 'x'>),
('y', <Parameter at 0x10077a158 'y'>), ('z', <Parameter at 0x10077a1b0 'z'>)]))
>>> sig.parameters['z'].name
'z'
>>> sig.parameters['z'].default
42
>>> sig.parameters['z'].kind
<_ParameterKind: 'POSITIONAL_OR_KEYWORD'>
```

*decorator*의 첫번째 부분에서는 시그니처의 `bind_partial()` 메서드를 사용하여 제공된 타입을 인수 이름에 부분적으로 바인딩 합니다.
다음은 어떤 일이 일어나는지에 대한 예입니다.

```python
>>> bound_types = sig.bind_partial(int, z=int)
>>> bound_types
<inspect.BoundArguments object at 0x10069bb50>
>>> bound_types.arguments
OrderedDict([('x', <class 'int'>), ('z', <class 'int'>)])
```

이 부분적인 바인딩에 대해서 누락된 인수는 무시됨을 알 수 있습니다(즉 `y`의 바인딩은 없습니다). 하지만 바인딩에서 가장 중요한 부분은 순서 *dictionary*인 `bound_types.arguments`의 생성입니다. 이 *dictionary*는 함수 시그니처과 동일한 순서로 제공된 값에 인수 이름을 매핑합니다. *decorator*의 경우 이 매핑은 이제 시행할 타입 *assertion*을 포함합니다.

*decorator*로 만들어진 실제 wrapper 함수에서 `sig.bind()` 메서드가 사용됩니다.
`bind()`는 누락된 인수를 허용하지 않는다는 점을 제외하고 `bind_partial()` 같습니다.
그래서 발생하는 상황은 다음과 같습니다.

```python
>>> bound_values = sig.bind(1, 2, 3)
>>> bound_values.arguments
OrderedDict([('x', 1), ('y', 2), ('z', 3)])
```

이 매핑 사용으로 비교적 쉬운 요구 *assertion*을 시행할 수 있습니다.

```python
for name, value in bound_values.arguments.items():
    if name in bound_types.arguments:
        if not isinstance(value, bound_types.arguments[name]):
            raise TypeError()
```

솔루션의 다소 미묘한 측면은 *assertion*이 기본 값으로 제공되지 않은 인수로 적용되지 않는다는 것입니다.
예를 들어 이 코드는 동작하는데 심지어 `items`의 기본 값이 "잘못된" 타입에도 동작한다는 것입니다.

```python
>>> @typeassert(int, list)
... def bar(x, items=None):
...     if items is None:
...         items = []
...     items.append(x)
...     return items
...
>>> bar(2)
[2]
>>> bar(2, 3)
TypeError: Argument items must be <class 'list'>
>>> bar(4, [1, 2, 3])
[1, 2, 3, 4]
```

마지막으로 *decorator* 인수 또는 함수 *annotation*을 사용하는 것입니다. 예를 들어 왜 이렇게 *annotation*을 보는 *decorator*를 작성하지 않는 것일까요?

```python
@typeassert
def spam(x:int, y, z:int=42):
    print(x, y, z)
```

*annotation*을 사용하지 않는 한가지 이유는 함수에 대한 각 인수에 단일 *annotation*만 할당할 수 있다는 것 때문입니다.
그러므로 *annotation*이 타입 *assertion*에 사용된 경우 실제로 다른 용도로는 사용될 수 없습니다.
마찬가지로 `@typeassert` *decorator*는 다른 목적으로 *annotation*을 사용하는 함수에서 동작하지 않습니다. 솔루션에 보인 것과 같이 *decorator* 인수를 사용함으로써 *decorator*는 훨씬 더 일반적인 목적으로 사용되며 *annotation*을 사용하는 함수조차도 모든 함수와 함께 사용될 수 있습니다.

함수 시그니처 객체에 대한 더 많은 정보는 [PEP 362]()//www.python.org/dev/peps/pep-0362/에서 찾아볼 수 있으며 [documentation for the `inspect` module](//docs.python.org/3/library/inspect.html)에서도 찾아 볼 수 있습니다.  [9.16장]()에도 추가 예제가 있습니다.

## 9.8. Defining Decorators As Part of a Class

#### Problem

클래스 정의 내부의 *decorator*를 정의하고 다른 함수 또는 메서드에 적용하려고 합니다.

#### Solution

클래스 내부에 *decorator*를 정의하는 것은 간단하지만 먼저 *decorator*가 적용될 방식을 정리하는 것이 좋습니다.
특히 인스턴스인지 또는 클래스 메서드에 적용할지의 여부입니다. 다음은 차이를 설명하는 예제입니다.

```python
from functools import wraps

class A:
    # Decorator as an instance method
    def decorator1(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print('Decorator 1')
            return func(*args, **kwargs)
        return wrapper

    # Decorator as a class method
    @classmethod
    def decorator2(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print('Decorator 2')
            return func(*args, **kwargs)
        return wrapper
```

다음은 두 *decorator*가 적용된 방법의 예입니다.

```python
# As an instance method
a = A()

@a.decorator1
def spam():
    pass

# As a class method
@A.decorator2
def grok():
    pass
```

자세히 보면 하나는 인스턴스 `a`에서 적용된 것이며 다른 하나는 클래스 `A`에서 적용된 것임을 알 수 있습니다.

#### Discussion

클래스에서 *decorator*를 정의하는 것이 언뜻 보면 이상해 보일 수 있지만 표준 라이브러리에 이 예제가 있습니다.
특히 built-in `@property` *decorator*가 실제로 각각 *decorator* 역할을 하는 `getter()`, `setter()`, `deleter()` 메서드를 가진 클래스입니다.

```python
class Person:
    # Create a property instance
    first_name = property()

    # Apply decorator methods
    @first_name.getter
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value
```

이런 방법으로 정의 된 주된 이유는 다양한 *decorator* 메서드가 연관된 `property` 인스턴스에서 상태를 조작하고 있기 때문입니다.
따라서 *decorator*가 뒤에서 정보를 기록하거나 결합해야 하는 문제가 있다면 이는 합리적인 방법입니다.

클래스에서 *decorator*를 작성할 때 혼란은 *decorator* 코드 자체에서 `self` 또는 `cls` 인수를 적절하게 사용함으로써 해결합니다. `decorator1()`이나 `decorator2()` 같은 가장 바깥쪽의 *decorator* 함수일지라도 `self` 또는 `cls` 인수를 제공해야 하며(클래스에 속하기 때문에), 내부적으로 생성된 wrapper 함수는 일반적으로 추가 인수를 포함할 필요가 없습니다.
이는 두 *decorator* 모두 작성된 `wrapper()` 함수가 `self` 인수를 포함하지 않는 이유입니다.
이 인수가 유일하게 필요할 때는 wrapper 인스턴스의 일부에 실제로 액세스 해야하는 상황일 경우입니다. 그게 아니면 신경 쓸 필요는 없습니다.

클래스에서 정의된 *decorator*가 가지는 마지막 미묘한 측면은 상속과 함께 잠재적인 사용에 관한 것입니다.
예를 들어 클래스 `A`에 정의된 *decorator*중 하나가 서브클래스 `B`에 정의된 메서드에 적용되길 원합니다.
이를 위해 코드를 다음과 같이 작성할 필요가 있습니다.

```python
class B(A):
    @A.decorator2
    def bar(self):
        pass
```

특히 문제의 *decorator*는 클래스 메서드로 정의되어야 하고 이를 적용할 때 명시적으로 슈퍼클래스 `A`의 이름을 사용해야 합니다. `@B.decorator2`와 같은 이름을 사용할 수는 없습니다. 메서드 정의 시에 클래스 `B`는 아직 생성되지 않았기 때문입니다.

## 9.9. Defining Decorators As Classes

#### Problem

*decorator*로 함수를 wrap하려고 하지만 결과가 *callable* 인스턴스가 됩니다. *decorator*가 클래스 정의 내부 외부 모두 동작해야 합니다.

#### Solution

인스턴스로 *decorator*를 정의하기 위해 `__call__()` 및 `__get__()` 메서드가 구현되어 있는지 확인해야 합니다.
예를 들어 이 코드는 간단한 프로파일링 레이어를 다른 함수로 가져오는 클래스를 정의합니다.

```python
import types
from functools import wraps

class Profiled:
    def __init__(self, func):
        wraps(func)(self)
        self.ncalls = 0

    def __call__(self, *args, **kwargs):
        self.ncalls += 1
        return self.__wrapped__(*args, **kwargs)

    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return types.MethodType(self, instance)
```

이 클래스를 사용하기 위해 클래스 내부나 외부에서 일반 *decorator*처럼 사용하면 됩니다.

```python
@Profiled
def add(x, y):
    return x + y

class Spam:
    @Profiled
    def bar(self, x):
        print(self, x)
```

다음은 이런 함수들의 동작을 보여주는 대화형 세션입니다.

```python
>>> add(2, 3)
5
>>> add(4, 5)
9
>>> add.ncalls
2
>>> s = Spam()
>>> s.bar(1)
<__main__.Spam object at 0x10069e9d0> 1
>>> s.bar(2)
<__main__.Spam object at 0x10069e9d0> 2
>>> s.bar(3)
<__main__.Spam object at 0x10069e9d0> 3
>>> Spam.bar.ncalls
3
```

#### Discussion

클래스로 *decorator*를 정의하는 것은 간단합니다. 하지만 다소 세부적인 설명이 필요한 사항이 있으며 특히 인스턴스 메서드에 *decorator*를 적용할 계획이라면 더욱 그렇습니다.

먼저, `functools.wraps()` 함수의 사용은 일반 *decorator*에서와 같은 목적으로 사용되며 wrap된 함수에서 *callable* 인스턴스로 중요한 메타데이터를 복사하는 것입니다.

다음으로, 솔루션에 표시된 `__get__()` 메서드를 간과하는 것이 일반적입니다. `__get__()`을 생략하고 다른 모든 코드를 동일하게 유지하면 *decorate*된 인스턴스 메서드를 호출하려고 할 때 이상한 일이 일어납니다.

```python
>>> s = Spam()
>>> s.bar(3)
TypeError: spam() missing 1 required positional arguments: 'x'
```

클래스에서 구현하는 함수가 검색될 때마다 `__get__()` 메서드가 [8.9장]()과 같이 *descriptor* 프로토콜의 일부로 호출되어 깨지기 때문입니다. 이 경우, `__get__()` 의 목적은 *바운드 메서드 객체*(`self` 인수를 메서드에 제공하는)를 생성하기 위한 것입니다. 다음은 기본적인 원리를 설명한 예제입니다.

```python
>>> s = Spam()
>>> def grok(self, x):
...     pass
...
>>> grok.__get__(s, Spam)
<bound method Spam.grok of <__main__.Spam object at 0x100671e90>>
```

이 장에서 `__get__()` 메서드는 바운드 메서드 객체가 적절히 생성되도록 합니다.
여기서 `type.MethodType()`는 바운드 메서드를 수동적으로 사용하기 위해 생성합니다.
바운드 메서드는 인스턴스가 사용될 경우에만 생성됩니다. 메서드가 클래스에 액세스하면 `__get__()`의 `instance` 인수가 `None`으로 설정되고 `Profiled` 인스턴스 자체가 반환됩니다. 이러면 누군가가 보여진 것처럼 `ncalls` 속성을 추출할 수 있게 됩니다.

이 혼란을 피하려면 [9.5장]()과 같이 *closure*와 `nonlocal` 변수를 사용하여 *decorator* 대안의 사용을 고려해야 합니다.

```python
import types
from functools import wraps

def profiled(func):
    ncalls = 0
    @wraps(func)
    def wrapper(*args, **kwargs):
        nonlocal ncalls
        ncalls += 1
        return func(*args, **kwargs)
    wrapper.ncalls = lambda: ncalls
    return wrapper

# Example
@profiled
def add(x, y):
    return x + y
```

이 예제는 `ncalls`에 대한 액세스가 이제 함수 속성으로 연결된 함수를 통해 제공된다는 점을 제외하고는 거의 같은 방식으로 동작합니다.

```python
>>> add(2, 3)
5
>>> add(4, 5)
9
>>> add.ncalls()
2
```

## 9.10. Applying Decorators to Class and Static Methods

#### Problem

*decorator*를 클래스나 스태틱 메서드에 적용하려고 합니다.

#### Solution

클래스와 스태틱 메서드에 *decorator*를 적용하는 것은 단순합니다. 하지만 그 전에 *decorator*에 `@staticmethod` 또는 `@classmethod`가 적용되어야 합니다.

```python
import time
from functools import wraps

# A simple decorator
def timethis(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        r = func(*args, **kwargs)
        end = time.time()
        print(end-start)
        return r
    return wrapper

# Class illustrating application of the decorator to different kinds of methods
class Spam:
    @timethis
    def instance_method(self, n):
        print(self, n)
        while n>0:
            n -= 1

    @classmethod
    @timethis
    def class_method(cls, n):
        print(cls, n)
        while n>0:
            n -= 1

    @staticmethod
    @timethis
    def static_method(n):
        print(n)
        while n > 0:
            n -= 1
```

클래스와 스태틱 메서드의 결과는 정상적으로 동작하지만 추가 타이밍이 있어야 합니다.

```python
s = Spam()
>>> s.instance_method(1000000)
<__main__.Spam object at 0x1006a6050> 1000000
>>> Spam.class_method(1000000)
<class '__main__.Spam'> 1000000
0.1133439540860371
>>> Spam.static_method(1000000)
1000000
0.11740279197692871
```

#### Discussion

*decorator*의 순서가 잘못되면 에러가 발생할 것입니다. 예를 들어 다음과 같이 사용하면

```python
class Spam:
    ...
    @timethis
    @staticmethod
    def static_method(n):
        print(n)
        while n > 0:
            n -= 1
```

그럼 스태틱 메서드는 충돌이 납니다.

```python
>>> Spam.static_method(1000000)
TypeError: 'staticmethod' object is not callable
```

여기서 `@classmethod` 와 `@staticmethod`의 문제는 실제로 직접적인 *callable* 객체를 생성하지 않는다는 것입니다.
대신 [8.9장]()에서 설명된것과 같이 특별한 *descriptor* 객체를 생성합니다.
따라서 다른 *decorator* 함수처럼 사용하려고 하면 *decorator*가 충돌됩니다.
이런 *decorator*들을 *list*의 맨 앞에 나타나는지 확인하여 문제를 해결합니다.

이 장의 매우 중요한 상황 중 한가지는 [8.12장]()에서 설명한 대로 *abatract* 기본 클래스에서 클래스 및 스태틱 메서드를 정의하는 것입니다.
예를 들어 *abstract* 클래스 메서드를 정의하려면 다음과 같은 코드를 사용할 수 있습니다.

```python
from abc import ABCMeta, abstractmethod

class A(metaclass=ABCMeta):
    @classmethod
    @abstractmethod
    def method(cls)
        pass
```

`@classmethod`와 `@abstractmethod`의 순서는 중요합니다. 두 *decorator*들을 뒤집으면 모든 것이 깨집니다.

## 9.11. Writing Decorators That Add Arguments to Wrapped Functions

#### Problem

wrap된 함수의 호출 시그니처에 추가 인수를 추가하는 *decorator*를 작성하려고 합니다.
하지만 추가된 인수가 함수의 기존 호출 규칙을 간섭할 수 없습니다.

#### Solution

추가 인수는 키워드 전용 인수를 사용하여 호출 시그니처에 삽입할 수 있습니다.
다음 *decorator*를 고려합니다.

```python
from functools import wraps

def optional_debug(func):
    @wraps(func)
    def wrapper(*args, debug=False, **kwargs):
        if debug:
            print('Calling', func.__name__)
        return func(*args, **kwargs)
    return wrapper
```

다음은 *decorator*가 동작하는 예제입니다.

```python
>>> @optional_debug
... def spam(a, b, c):
...     print(a, b, c)
...
>>> spam(1, 2, 3)
1 2 3
>>> spam(1, 2, 3, debug=True)
Calling spam
1 2 3
```

#### Discussion

wrap된 함수의 시그니처에 인수를 추가하는 것은 *decorator* 사용의 대부분의 일반적인 예제가 아닙니다.
하지만 일종의 코드 복제 패턴을 피하는 데는 유용한 테크닉일 수 있습니다.
예를 들어 다음 코드에서

```python
def a(x, debug=False):
    if debug:
        print('Calling a')
    ...

def b(x, y, z, debug=False):
    if debug:
        print('Calling b')
    ...

def c(x, y, debug=False):
    if debug:
        print('Calling c')
```

다음과 같이 refactor 할 수 있습니다

```python
@optional_debug
def a(x):
    ...

@optional_debug
def b(x, y, z):
    ...

@optional_debug
def c(x, y):
    ...
```

이 장의 구현은 키워드 전용 인수가 `*args`와 `**kwargs* 파라미터를 받는 함수에 추가되기 쉽다는 사실에 의존합니다.
키워드 전용 인수를 사용함으로써 특수한 경우로 선택되고 나머지 위치와 키워드 인수만을 사용하는 후속 호출에서 제거됩니다.

여기서 한가지 까다로운 부분은 추가된 인수와 wrap된 함수의 인수 사이의 잠재적인 이름 충돌에 관한 것입니다.
예를 들어 `@optional_debug` *decorator*가 이미 `debug` 인수를 가진 함수에 적용되었다면 오류가 발생합니다. 그런 것을 고려한다면 추가적인 체크가 더해져야 합니다.

```python
from functools import wraps
import inspect

def optional_debug(func):
    if 'debug' in inspect.getargspec(func).args:
        raise TypeError('debug argument already defined')

    @wraps(func)
    def wrapper(*args, debug=False, **kwargs):
        if debug:
            print('Calling', func.__name__)
        return func(*args, **kwargs)
    return wrapper
```

이 장에 대한 최종적인 개선은 함수 시그니처의 적절한 관리에 관한 것입니다.
민첩한 프로그래머는 wrap된 함수의 시그니처가 잘못 되었음을 깨달을 것입니다.

```python
>>> @optional_debug
... def add(x, y):
...     return x + y
...
>>> import inspect
>>> print(inspect.signature(add))
(x, y)
```

이는 다음과 같이 수정하여 해결할 수 있습니다.

```python
from functools import wraps
import inspect

def optional_debug(func):
    if 'debug' in inspect.getargspec(func).args:
        raise TypeError('debug argument already defined')

    @wraps(func)
    def wrapper(*args, debug=False, **kwargs):
        if debug:
            print('Calling', func.__name__)
        return func(*args, **kwargs)

    sig = inspect.signature(func)
    parms = list(sig.parameters.values())
    parms.append(inspect.Parameter('debug', inspect.Parameter.KEYWORD_ONLY, default=False))
    wrapper.__signature__ = sig.replace(parameters=params)
    return wrapper
```

이 변경으로 wrapper의 시그니처는 이제 올바르게 `debug` 인수를 반영할 것입니다.

```python
>>> @optional_debug
... def add(x, y):
...     return x + y
...
>>> print(inspect.signature(add))
(x, y, *, debug=False)
>>> add(2, 3)
5
```

[9.16장]()에 함수 시그니처에 대한 자세한 정보를 참고하시기 바랍니다.

## 9.12. Using Decorators to Patch Class Definitions

#### Problem

상속이나 메타클래스 사용 없이 클래스 정의의 부분을 검사하거나 다시 작성하여 행동을 변경하려고 합니다.

#### Solution

이는 클래스 *decorator*의 완벽한 사용이 될 수 있습니다. 예를 들어 다음은 클래스 *decorator*를 `__getattribute__` 특수 메서드로 다시 작성하여 로깅을 수행합니다.

```python
def log_getattribute(cls):
    # Get the original implementation
    orig_getattribute = cls.__getattribute__

    # Make a new definition
    def new_getattribute(self, name):
        print('getting:', name)
        return orig_getattribute(self, name)

    # Attach to the class and return
    cls.__getattribute__ = new_getattribute
    return cls

# Example use
@log_getattribute
class A:
    def init__(self, x):
        self.x = x
    
    def spam(self):
        pass
```

다음은 이 솔루션에서 클래스를 사용했을 때 일어나는 상황입니다.

```python
>>> a = A(42)
>>> a.x
getting: x
42
>>> a.spam()
getting: spam
```

#### Discussion

클래스 *decorator*는 종종 *mixin*이나 메타클래스가 포함된 다른 고급 기술에 대한 직접적인 대안으로 사용될 수가 있습니다. 예를 들어 솔루션의 대체 구현은 다음과 같은 상속과 관련된 것이 있을 것입니다.

```python
class LoggedGetattribute:
    def __getattribute__(self, name):
        print('getting:', name)
        return super().__getattribute__(name)

# Example:
class A(LoggedGetattribute):
    def __init__(self, x):
        self.x = x
    def spam(self):
        pass
```

이는 동작하고, 이해하기도 쉽지만 [8.7장]()에 설명한 대로 *MRO(method resolution order)*, `super()` 및 다른 상속의 측면을 알고 있어야 합니다.
어떤 의미에서 클래스 *decorator* 솔루션은 동작 방식이 훨씬 더 직접적이며 상속 계층에 새로운 종속성을 도입하지는 않습니다.
결과적으로 `super()` 함수에 의존하지 않기 때문에 약간 더 빠릅니다.

다중 클래스 *decorator*를 클래스에 적용하는 경우 애플리케이션 순서가 중요할 수 있습니다.
예를 들어 완전히 새로운 구현으로 메서드를 대체하는 *decorator*는 아마도 기존의 메서드를 몇가지 추가 논리로 wrap하는 데코레이터 전에 적용해야 할 것입니다.

[8.13장]()에 실제 사용 되는 클래스 *decorator*의 또다른 예제가 있습니다.

## 9.13. Using a Metaclass to Control Instance Creation

#### Problem

싱글턴, 캐싱 또는 다른 유사한 기능을 구현하기 위해 인스턴스가 생성되는 방식을 변경하려고 합니다.

#### Solution

Python 프로그래머가 알고 있듯, 클래스를 정의하면 인스턴스를 생성하는 함수처럼 호출합니다.

```python
class Spam:
    def __init__(self, name):
        self.name = name

a = Spam('Guido')
b = Spam('Diana')
```

이 단계를 커스터마이즈 하려면 메타클래스를 정의하고 `__call__()` 메서드를 어떤 방법으로 다시 구현하면 됩니다.
설명하자면 어떠한 인스턴스 생성도 원하지 않는다고 가정합니다.

```python
class NoInstances(type):
    def __call__(self, *args, **kwargs):
        raise TypeError("Can't instantiate directly")

# Example
class Spam(metaclass=NoInstances):
    @staticmethod
    def grok(x):
        print('Spam.grok')
```

이 경우 사용자는 정의된 스태틱 메서드를 호출할 수 있지만 정상적인 방법으로 인스턴스를 생성하는 것은 불가능합니다.

```python
>>> Spam.grok(42)
Spam.grok
>>> s = Spam()
TypeError: Cannot instantiate directly
```

이제 싱글턴 패턴을 구현한다고 가정해 보겠습니다(즉, 하나의 인스턴스만 생성될 수 있는 클래스입니다). 이 또한 비교적 단순합니다.

```python
class Singleton(type):
    def __init__(self, *args, **kwargs):
        self.__instance = None
        super().__init__(*args, **kwargs)

    def __call__(self, *args, **kwargs):
        if self.__instance is None:
            self.__instance = super().__call__(*args, **kwargs)
            return self.__instance
        else:
            return self.__instance

# Example
class Spam(metaclass=Singleton):
    def __init__(self):
        print('Creating Spam')
```

이 경우 하나의 인스턴스만 만들어집니다.

```python
>>> a = Spam()
Creating Spam
>>> b = Spam()
>>> a is b
True
>>> c = Spam()
>>> a is c
True
```

마지막으로 [8.25장]()에 설명한 대로 캐시된 인스턴스를 만든다고 가정해 보겠습니다. 다음은 그것을 구현하는 메타클래스입니다.

```python
import weakref

class Cached(type):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__cache = weakref.WeakValueDictionary()

    def __call__(self, *args):
        if args in self.__cache:
            return self.__cache[args]
        else:
            obj = super().__call__(*args)
            self.__cache[args] = obj
            return obj

# Example
class Spam(metaclass=Cached):
    def __init__(self, name):
        print('Creating Spam({!r})'.format(name))
        self.name = name
```

다음은 이 클래스의 행동을 보여주는 예제입니다.

```python
>>> a = Spam('Guido')
Creating Spam('Guido')
>>> b = Spam('Diana')
Creating Spam('Diana')
>>> c = Spam('Guido')       # Cached
>>> a is b
False
>>> a is c                  # Cached value returned
True
```

#### Discussion

다양한 인스턴스 생성 패턴을 구현하기 위해 메타클래스를 사용하는 것은 종종 메타클래스를 포함하지 않는 다른 솔루션보다 우아한 접근 방법이 될 수 있습니다.
예를 들어 메타클래스를 사용하지 않을 경우 일종의 추가 팩토리 함수 뒤에 클래스를 숨겨야 할 수 있습니다.
예를 들어 싱글턴을 얻기 위해 다음과 같은 해킹을 할 수 있습니다.

```python
class _Spam:
    def __init__(self):
        print('Creating Spam')

_spam_instance = None
def Spam():
    global _spam_instance
    if _spam_instance is not None:
        return _spam_instance
    else:
        _spam_instance = _Spam()
        return _spam_instance
```

메타클래스를 포함하는 솔루션이 훨씬 더 심화된 개념을 포함하지만, 결과 코드가 깨끗해고 해킹 요소가 덜해 보입니다.

[8.25장]()에 캐시된 인스턴스 생성, weak 참조와 다른 세부사항에 대한 자세한 정보를 참조하시기 바랍니다.

## 9.14. Capturing Class Attribute Definition Order

#### Problem

클래스 본체 내부에 속성과 메서드가 정의된 순서를 자동으로 기록하여 다양한 작업에서 사용할 수 있게 하려고 합니다(*serializing*, 데이터베이스에 mapping 등).

#### Solution

클래스 정의의 본문에 대한 정보를 캡처하는 방법은 메타클래스 사용을 통해 쉽게 달성할 수 있습니다.
다음은 `OrderedDict`를 사용하여 *descriptor*의 정의 순서를 캡처하기 위한 메타클래스의 예입니다.

```python
from collections import OrderedDict

# A set of descriptors for various types
class Typed:
    _expected_type = type(None)
    def __init__(self, name=None):
        self._name = name

    def __set__(self, instance, value):
        if not isinstance(value, self._expected_type):
            raise TypeError('Expected ' + str(self._expected_type))
        instance.__dict__[self._name] = value

class Integer(Typed):
    _expected_type = int

class Float(Typed):
    _expected_type = float

class String(Typed):
    _expected_type = str

# Metaclass that uses an OrderedDict for class body
class OrderedMeta(type):
    def __new__(cls, clsname, bases, clsdict):
        d = dict(clsdict)
        order = []
        for name, value in clsdict.items():
            if isinstance(value, Typed):
                value._name = name
                order.append(name)
        d['_order'] = order
        return type.__new__(cls, clsname, bases, d)

    @classmethodd
    def __prepare__(cls, clsname, bases):
        return OrderedDict()
```

이 메타클래스에서 *descriptor*의 정의 순서는 클래스 본체를 실행하는 동안 `OrderedDict`을 사용하여 캡쳐됩니다.
이름 순서의 결과는 *dictionary*에서 추출되어 클래스 속성 `_order`에 저장됩니다.
그리고 이는 클래스의 메서드에서 다양한 방법으로 사용될 수 있습니다.
에를 들어 다음은 순서를 사용하여 인스턴스 데이터를 CSV의 행으로 *serialize*하는 메서드를 구현하는 간단한 클래스입니다.

```python
class Structure(metaclass=OrderedMeta):
    def as_csv(self):
        return ','.join(str(getattr(self, name)) for name in self._order)

# Example use
class Stock(structure):
    nams = String()
    shares = Integer()
    price = Float()
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
```

다음은 `Stock` 클래스의 사용을 설명하는 대화형 세션입니다.

```python
>>> s = Stock('GOOG', 100, 490.1)
>>> s.name
'GOOG'
>>> s.as_csv()
'GOOG,100,490.1'
>>> t = Stock('AAPL', 'a lot', 610.23)
TypeError: shares expect <classs 'int'>
```

#### Discussion

이 방법의 핵심은 `OrderedMeta` 메타 클래스에 정의된 `__prepare__()` 메서드입니다.
이 메서드는 클래스 이름, base 클래스와 함께 클래스 정의를 시작할 때 즉시 호출됩니다.
그런 다음 클래스 본체를 처리할 때 사용할 매핑 객체를 반환해야 합니다.
일반 *dictionary* 대신 `OrderedDict`를 사용하여 반환함으로써 정의 순서의 결과가 쉽게 캡처됩니다.

자신만의 *dictionary*와 같은 객체를 만들고자 한다면 이 기능을 더욱 확장할 수 있습니다. 예를 들어 중복 정의를 거부하는 이 변형된 솔루션을 고려하면

```python
from collections import OrderedDict

class NoDupOrderedDict(OrderedDict):
    def __init__(self, clsname):
        self.clsname = clsname
        super().__init__()
    def __setitem__(self, name, value):
        if name in self:
            raise TypeError('{} already defined in {}'.format(name, self.clsname))
        super().__setitem__(name, value)

class OrderedMeta(type):
    def __new__(cls, clsname, bases, clsdict):
        d = dict(clsdict)
        d['_order'] = [name for name in clsdict if name[0] != '_']
        return type.__new__(cls, clsname, bases, d)

    @classmethod
    def __prepare__(cls, clsname, bases):
        return NoDupOrderedDict(clsname)
```

다음은 이 메타클래스를 사용하고 중복된 엔트리를 가진 클래스를 만들면 어떤 일이 일어나는지에 대한 것입니다.

```python
>>> class A(metaclass=OrderedMeta):
...     def spam(self):
...         pass
...     def spam(self):
...         pass
...
TypeError: spam already defined in A
```

이 장의 마지막 중요한 부분은 메타클래스 `__new__()` 메서드에서 수정된 *dictionary* 처리에 관한 것입니다.
심지어 클래스가 다른 *dictionary* 사용으로 정의되었더라도 최종 클래스 객체를 만들 때 이 *dictionary*을 적절한 `dict` 인스턴스로 변환해야 합니다.
이는 `d = dict(clsdict)` 문의 목적입니다.

정의 순서를 캡처할 수 있다는 것은 특정 애플리케이션에 대해서는 미묘하지만 중요한 기능입니다.
예를 들어 객체 관계 매퍼에서 클래스는 다음과 비슷한 방식으로 작성될 수 있습니다.

```python
class Stock(Model):
    name = String()
    shares = Integer()
    price = Float()
```

들여다보면, 코드는 객체를 데이터베이스의 테이블(예제의 `as_csv()` 메서드의 기능과 비슷합니다)에서 *tuple* 또는 행에 매핑하기 위해 정의 순서를 캡처하고자 할 수 있습니다.
솔루션에서 보인 것은 종종 다른 접근 방식보다 매우 간단합니다(일반적으로 *descriptor* 클래스 내에 숨겨진 카운터를 유지하는 것이 포함됩니다).

## 9.15. Defining a Metaclass That Takes Optional Arguments

#### Problem

클래스 정의가 선택적 인수를 제공할 수 있는 메타클래스를 정의하여 타입 생성 중 처리되는 측면을 제어하거나 구성하는 것을 가능하게 하려고 합니다.

#### Solution

클래스를 정의할 때 Python은 `class` 문에서 `metaclass` 키워드 인수를 사용하여 메타클래스를 지정할 수 있습니다. 예를 들어 다음 *abstract* 기본 클래스에서

```python
from abc import ABCMeta, abstractmethod

class IStream(metaclass=ABCMeta):
    @abstractmethod
    def read(self, maxsize=None):
        pass

    @abstractmethod
    def write(self, data):
        pass
```

하지만 커스텀 메타클래스에서는 다음과 같이 추가적인 키워드 인수가 제공될 수 있습니다.

```python
class Spam(metaclass=MyMeta, debug=True, synchronize=True):
    ...
```

이러한 키워드 인수를 메타클래스에서 지원하려면 키워드 전용 인수를 사용하여 `__prepare__()`, `__new__()`, `__init__()` 메서드에서 키워드 전용 인수를 정의해야 합니다.

```python
class MyMeta(type):
    # Optional
    @classmethod
    def __prepare__(cls, name, bases, *, debug=False, synchronize=False):
        # Custom processing
        ...
        return super().__prepare__(name, bases)

    # Required
    def __new__(cls, name, bases, ns, *, debug=False, synchronize=False):
        # Custom processing
        ...
        return super().__new__(cls, name, bases, ns)

    # Required
    def __init__(self, name, bases, ns, *, debug=False, synchronize=False):
        # Custom processing
        ...
        super().__init__(name, bases, ns)
```

#### Discussion

선택적 키워드 인수를 메타클래스에 추가하려면 추가 인수와 관련된 모든 메서드에 전달되므로 클래스 작성과 관련된 모든 단계를 이해해야 합니다.
`__prepare__()` 메서드는 **먼저 호출되며** 처리중인 다른 클래스 정의 본체 앞에서 클래스 네임스페이스를 만드는 데 사용됩니다.
일반적으로 이 메서드는 *dictionary* 또는 다른 매핑 객체를 반환합니다.
`__new__()` 메서드는 타입 객체의 결과를 인스턴스화 하는 데 사용됩니다.
**클레스 본체가 완전히 실행된 후에 호출됩니다.**
`__init__()` 메서드는 *last*라고 불리며 다른 추가적인 초기화 단계를 수행하는 데 사용됩니다.

메타클래스를 작성할 때 `__new__()` 또는 `__init__()` 메서드만 정의하는 것이 일반적이지만 둘 다 정의하지는 않습니다.
그러나 추가 키워드 인수를 받으려면 두 메서드 모두 제공되어야 하며 호환 가능한 시그니처가 주어져야 합니다.
기본 `__prepare__()` 메서드는 키워드 인수 집합을 받긴 하지만 무시합니다.
추가 인수가 클래스 네임스페이스 생성 관리에 어떻게든 영향을 주는 경우에만 직접 스스로 정의해야 합니다.

이 장에서 키워드 전용 인수를 사용하면 이러한 인수가 클래스 생성 중에 키워드에 의해서만 제공된다는 사실을 반영합니다.

메타클래스를 구성하기 위한 키워드 인수의 지정은 비슷한 목적으로 클래스 변수를 사용하기 위한 대안으로 보여질 수 있습니다.

```python
class Spam(metaclass=MyMeta)
    debug = True
    synchronize = True
    ...
```

인수와 같은 파라미터를 제공하는 이점은 클래스의 네임스페이스를 클래스 생성과 관련된 추가 이름으로 오염시키지 않고 클래스 문장의 후속 실행을 하지 않는 것입니다.
추가로, 클래스 본체의 다른 명령을 처리하기 이전에 실행되는 `__prepare__()` 메서드에서 사용이 가능합니다.
반면 클래스 변수에서는 메타클래스의 `__new__()`와 `__init__()` 메서드에만 액세스할 수 있습니다.