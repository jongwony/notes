---
layout: post
title: Python cookbook Chapter 2 한글
tags: ['python', 'docs', 'string', '한글']
progress: 20
---

<div class='warn'>
이 문서는 Python Coobook 3rd edition - O'REILLY, David Beazley & Brian K. jones 를 참고한 것이며 <a href="//wikidocs.net/book/1">Python을 완전히 처음 접하는 경우</a>에는 적합하지 않습니다.<br>개인적으로 공부한 내용이라 오역이 있을 수 있으며 <strong>Memo</strong>에는 실제 C를 이용한 테스트를 하지 않았으므로 이해를 위한 추측성 부분이 많음에 유의하시기 바랍니다.<br>
</div>

거의 모든 유용한 프로그램은 데이터를 파싱하던지 또는 출력을 생성하는 일종의 텍스트 처리를 포함합니다. 이 챕터는 문자열 분리, searching, substitution, lexing, parsing과 같은 텍스트 조작을 포함하는 일반적인 문제에 초점을 맞춥니다. 이러한 많은 작업은 `string`의 `built-in method`를 사용하여 쉽게 해결할 수 있습니다. 하지만 좀더 복잡한 연산을 수행하려면 `regular expressions`를 사용하거나 본격적인 `parser`를 만들어야 할 수 있습니다. 이 모든 주제들을 담았습니다. 또한 유니코드로 작업할 때 몇가지 까다로운 부분을 다룹니다.

## 2.1 복합적인 Delimiter에서 문자열 분리

#### Problem

필드에서 문자열 분리를 하고 싶은데 `delimiter(구분 기호)` (및 그 주위의 `space`)가 문자열 전체에서 일관성이 없습니다.

#### Solution

`string` 객체에서의 `split()` 메서드는 매우 단순한 경우를 의미하고, 복합적인 `delimiter`를 허용하지 않거나 `delimiter` 주위의 가능한 `whitespace`를 고려하지 못합니다. 좀더 유연할 필요가 있을 때는 `re.split()` 메서드를 사용합니다.

```python
line = 'asdf fjdk; afed, fjek,asdf,         foo'

import re
print(re.split(r'[;,\s]\s*', line))        # ['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
```

`re.split()` 함수는 분리 기호에 복합적인 패턴을 지정할 수 있기 때문에 유용합니다. 예를 들어 위의 solution에서 보듯이 분리 기호는 (,) (;) 또는 `whitespace(\s)` 뒤에 임의의 추가적인 `whitespace` 입니다. 패턴이 발견될 때마다, 전체적으로 매치되는 부분은 매치된 양 쪽에 있는 필드 사이에서 `delimiter`가 됩니다. 결과는 `str.split()`과 같이 필드들의 `list`를 반환합니다.

`re.split()`을 사용할 때는 괄호 안에 `capture group`을 포함하는 `regular expression` 패턴을 약간 조심해야 할 필요가 있습니다. 그 `capture group` 사용한다면 매치된 텍스트도 결과에 포함됩니다.

```python
fields = re.split(r'(;|,|\s)\s*', line)
print(fields)   # ['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
```

분리된 `character`를 얻는 것은 특정 상황에 유용할 수 있습니다. 예를 들어 나중에 출력 문자열을 수정하려면 `split character`가 필요할 수 있습니다.

```python
values = fields[::2]
delimiters = fields[1::2] + ['']
print(values)       # ['asdf, 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
print(delimiters)   # [' ', ';', ',', ',', ',', '']

# Reform the line using the same delimiters
print(''.join(v+d for v, d in zip(values, delimiters))) # 'asdf fjdk;afed,fjek,asdf,foo'
```

결과의 구분 기호를 사용하고 싶지 않지만 여전히 괄호를 사용하여 `regular expression` 패턴의 그룹을 사용하고자 한다면 `(?:...)`로 지정되는 `noncapture group`을 사용하면 됩니다.

```python
re.split(r'(?:,|;|\s)\s*', line)
```

#### Memo

문자열 앞의 `r`은 그 문자열이 `raw string`이라는 것을 알려주는 것입니다.

백슬래시 충돌 문제를 이 `r`을 통해 해결할 수 있습니다.

[참고](//wikidocs.net/4308)

## 2.2 문자열의 처음과 끝에 매칭되는 텍스트

#### Problem

파일 이름이나 확장자, `URL scheme` 등 특정 텍스트 패턴의 문자열의 시작 또는 끝을 체크할 필요가 있습니다.

#### Solution

문자열의 시작 또는 끝을 체크하는 간단한 방법은 `str.startswith()` 또는 `str.endswith()` 메서드를 사용하는 것입니다.

```python
filename = 'spam.txt'
filename.endswith('.txt')       # True
filename.startswith('file:')    # False
url = 'http://www.python.org'
url.startswith('http:')         # True
```

여러 선택에 대해 체크해야 하는 경우 간단히 `startswith()` 또는 `endswith()`에 가능한 `tuple`을 제공하면 됩니다.

```python
import os
filenames = os.listdir('.')
# filenames = ['Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h']
print([name for name in filenames if name.endswith(('.c', '.h'))])
print(any(name.endswith('.py') for name in filenames))      # True
```

여기 다른 예시도 있습니다.

```python
from urllib.request import urlopen

def read_data(name):
    if name.startswith(('http:', 'https:', 'ftp:')):
        return urlopen(name).read()
    else:
        with open(name) as f:
            return f.read()
```

이상하게도 `tuple`이 실제로 `input`으로 요구됩니다. `list`나 `set`으로 지정된 선택을 했다면 `tuple`을 먼저 사용함으로써 변환해 주어야 합니다.

```python
choices = ['http:', 'ftp:']
url = 'http://www.python.org'
url.startswith(choices)         # TypeError startswith first arg must be str or a tuple of str, not list
url.startswith(tuple(choices))  # True
```

#### Discussion

`startswith()`와 `endswith()` 메서드는 기본적인 `prefix`와 `suffix` 검사를 수행하기 위한 매우 편리한 방법을 제공합니다. `slice`를 써서 비슷한 작업이 수행될 수 있지만, 조금 아름다운 코드는 되지 못합니다.

```python
filename = 'spam.txt'
filename[-4:] == '.txt'         # True
url = 'http://www.python.org'
url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'  # True
```

또한 `regular expression`로 사용하려는 경향이 있을 경우가 있습니다.

```python
import re
url = 'http://python.org'
re.match('http:|https:|ftp:', url)
```

이 역시 동작하지만, 종종 단순한 매치에는 과도합니다. solution을 사용하는 것이 좀 더 간단하고 빠르게 실행됩니다.

마지막으로 하지만 적어도, `startswith()`와 `endswith()` 메서드가 다른 일반적인 `data reduction`같은 `operation`과 결합 될 때 보기 좋습니다. 예를 들어 특정 종류의 파일이 있는지 디렉터리를 체크하는 `statement`는 다음과 같습니다.

```python
if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
    pass
```

## 2.3 Shell Wildcard 패턴을 사용하여 문자열 매칭

#### Problem

`Unix shell`에서 동작할 때 일반적으로 사용되는 `wildcard`(`*.py,Dat[0-9]*.csv`와 같은) 패턴과 동일한 사용으로 텍스트를 매칭하고 싶습니다.

#### Solution

`fnmatch` 모듈은 어떤 매칭을 수행하는데 사용되는 두 함수 `fnmatch()`와 `fnmatchcase()`를 제공합니다. 사용은 간단합니다.

```python
from fnmatch import fnmatch, fnmatchcase
fnmatch('foo.txt', '*.txt')         # True
fnmatch('foo.txt', '?oo.txt')       # True
fnmatch('Dat45.csv', 'Dat[0-9]*')   # True

names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
print([name for name in names if fnmatch(name, 'Dat*.csv')])
# ['Dat1.csv', 'Dat2.csv']
```

일반적으로 `fnmatch()`는 파일 시스템 아래의(다양한 운영체제에 따라 다른) 동일한 대소문자를 구분하는데 사용하여 패턴을 매치합니다.

```python
# On OS X (Mac)
fnmatch('foo.txt', '*.TXT')     # False

# On Windows
fnmatch('foo.txt', '*.TXT')     # True
```

이런 구별이 중요해질 경우에는 대신 `fnmatchcase()`를 사용하시면 됩니다. 이는 제공한 대 소문자 규칙을 기반으로 정확하게 매치됩니다.

```python
from fnmatch import fnmatchcase
fnmatchcase('foo.txt', '*.TXT') # False
```

이런 함수의 `overlooked feature`(포괄적인 기능)은 파일 이름이 아닌 문자열의 데이터 처리와 함께 잠재적으로 사용되는 것입니다.
예를 들어 다음과 같이 주소의 `list`를 가지고 있다고 하면

```python
addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY'
]
```

`list comprehension`을 다음과 같이 쓸 수 있습니다.

```python
from fnmatch import fnmatchcase
print([addr for addr in addresses if fnmatchcase(addr, * ST')])
# ['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
print([addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')])
# ['5412 N CLARK ST']
```

#### Discussion

`fnmatch`로 수행된 매칭은 간단한 문자열 메서드의 기능과 `regular expression`의 모든 기능 사이의 어디에서나 위치합니다. 단지 데이터 처리 연산의 `wildcard`를 허용하기 위한 간단한 메커니즘을 제공하려면 종종 합리적인 해결책이 될 수 있습니다.

만약 실제 파일 이름을 매치하는 코드를 쓰려고 한다면 [5.13장]()의 `glob` 모듈을 대싱 사용하시면 됩니다.

## 2.4 텍스트 패턴을 위한 Matching과 Searching

#### Problem

특정 패턴을 위한 텍스트를 매치하거나 찾고 싶습니다.

#### Solution

텍스트를 간단히 글자 그대로 매치하려고 한다면, 단지 `str.find()`, `str.endswith()`, `str.startswith()`같은 기본적인 `string` 메서드를 사용할 수 있습니다. 

```python
text = 'yeah, but no, but yeah, but no, but yeah'

# Exact match
print(text == 'yeah')           # False

# Match at start or end
print(text.startswith('yeah'))  # True
print(text.endswith('no'))      # False

# Search for the location of the first occurrence
text.find('no')                 # 10
```

좀 더 복잡한 매칭을 위해서는 `re` 모듈과 `regular expression`을 사용하면 됩니다. `regular expression`의 기본적인 메커니즘을 설명하기 위해 "11/27/2012" 같이 날짜를 지정된 숫자에 매치하길 원한다고 하면

```python
text1 = '11/27/2012'
text2 = 'Nov 27, 2012'

import re
# Simple matching: \d+ means match one or more digits
def textmatch(text)
    if re.match(r'\d+/\d+/\d+', text):
        print('yes')
    else:
        print('no')

textmatch(text1)        # yes
textmatch(text2)        # no
```

같은 패턴을 사용하여 많은 양의 매칭을 수행하려고 하면 `regular expression` 패턴을 먼저 패턴 객체로 `precompile`하는 것이 일반적인 방법입니다.

```python
datepat = re.compile(r'\d+/\d+/\d+')

def textmatch(text):
    if datepat.match(text):
        print('yes')
    else:
        print('no')

textmatch(text1)        # yes
textmatch(text2)        # no
```

`match()`는 항상 문자열의 시작부분에서 일치하는 부분을 찾으려고 합니다. 패턴이 일어나는 모든 부분의 텍스트를 찾으려면 `findall()` 메서드를 대신 사용하면 됩니다.

```python
text = 'Todays is 11/27/2012. PyCon starts 3/13/2013.'
print(datepat.findall(text)) # ['11/27/2012', '3/13/2013']
```

`regular expression`을 정의할 때는 괄호 안의 패턴의 일부분을 묶어 `capture group`을 도입하는 것이 일반적입니다.

```python
datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
```

`capture group`들은 각 그룹의 내용을 개별적으로 추출할 수 있기 때문에 매치된 텍스트의 후속 처리를 단순화하는 것입니다.

```python
m = datapat.match('11/27/2012')

# Extract the contents of each group
print(m.group(0))       # '11/27/2012'
print(m.group(1))       # 11
print(m.group(2))       # 27
print(m.group(3))       # 2012
print(m.groups())       # ('11', '27', '2012')

# Find all matches (notice splitting into tuples)
text = 'Today is 11/27/2012. PyCon starts 3/13/2013'
datepat.findall(text)   # [('11', '27', '2012'), ('3', '13', '2013')]

for month, day, year in datepat.findall(text):
    print('{}-{}-{}'.format(year, month, day))
```

`findall()` 메서드는 텍스트를 검색하고 모든 매치를 찾아 그 리스트를 반환합니다. 매치를 순회하면서 찾으려면 `finditer()` 메서드를 사용하시면 됩니다.

```python
for m in datepat.finditer(text):
    print(m.groups())
```

#### Discussion

`regular expression`의 이론에 대한 기본적인 튜토리얼은 이 책의 범위를 벗어납니다. 하지만 위에서 소개한 방법은 `re` 모듈을 사용하여 텍스트를 검색하고 매칭하는 데 절대적인 기본 사항을 설명합니다. 필수적인 기능은 `re.compile()`을 사용하여 처음 패턴을 컴파일 하고 `match()`, `findall()`, 또는 `finditer()`같은 메서드를 사용하는 것입니다.

패턴을 지정할 때는 `'r(\d+)/(\d+)/(\d+)'`와 같은 `raw string`을 사용하는 것이 상대적으로 일반적입니다. 이런 문자열은 백슬래시 문자를 해석되지 않고 남기며 `regular expression`의 내용에 유용할 수 있습니다. 그렇지 않으면 이중 백슬래시를 `'(\\d+)/(\\d+)/(\\d+)'`와 같이 사용해야 합니다.

`match()` 메서드가 문자열의 시작 부분 부터만 체크한다는 것에 주의하셔야 합니다. 원하지 않는 매칭이 일어날 수 있습니다.

```python
# 앞 부분 부터 맞기만 하면 됨 (정확한 매칭은 아님)
m = datepat.match('11/27/2012abcdef')
print(m.group())        # '11/27/2012'
```

정확한 매칭을 하려면 패턴에 `end-marker($)`를 포함해야 합니다.

```python
datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
print(datepat.match('11/27/2012abcdef'))        # None
print(datepat.match('11/27/2012'))              # <_sre.SRE_Match object; span=(0, 10), match='11/27/2012'>
```

마지막으로 단순하게 텍스트 매칭/검색 만 수행하려면 컴파일 단계를 건너 뛰고 `re` 모듈의 모듈 레벨 함수를 대신 사용하는 방법이 있습니다.

```python
re.findall(r'(\d+)/(\d+)/(\d+)', text)           # [('11', '27', '2012'), ('3', '13', '2013')]
```

그러나 매칭이나 검색을 많이 수행할 경우에는, 보통 패턴을 먼저 컴파일 하고 계속해서 사용하는 것이 좋습니다. 모듈 레벨의 함수는 최근에 컴파일 된 패턴의 캐시를 유지하므로, 성능에 크게 영향을 주진 않지만 지신이 직접 컴파이 한 패턴을 사용함으로써 추가적인 처리와 몇가지 조회를 줄일 수는 있습니다.